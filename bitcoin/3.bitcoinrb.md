# 3. bitcoinrb

2022/05/19更新 Shigeichiro Yamasaki

bitcoin core API をRuby から操作する rubygems  ライブラリの基本操作

bitcoinを利用するアプリを作成するためには、bitcoinrbなどのライブラリの利用が必要です。

2. bitcoin coreの詳細では、署名にワレットの機能を利用していましたが、ここでは、inputごとに自分で署名を作成し、トランザクションに埋め込みます。

## 技術情報

* bitcoinrb WiKi

開発者の安土さんによる Wikiです。
基本的な使用法は、ここでわかります。

[https://github.com/chaintope/bitcoinrb/wiki](https://github.com/chaintope/bitcoinrb/wiki)

* bitcoinrb のクラスとメソッドの一覧

[https://www.rubydoc.info/gems/bitcoinrb/0.1.5](https://www.rubydoc.info/gems/bitcoinrb/0.1.5)

## インストール方法とRubyのバージョン

### Ruby言語のインストール

Ruby 2.7.6 を基本とします。

[Ruby インストール](https://github.com/ShigeichiroYamasaki/yamalabo/blob/master/ruby.md)

### ubuntuでのbitcoinrbのインストール

```bash
sudo apt install -y libleveldb-dev
gem install bitcoinrb
```

### MacOSXでのbitcoinrbのインストール

```bash
brew install --build-from-source leveldb
gem install bitcoinrb
```

## 事前準備

### bitcoin core を起動しておく

* bitcoinrb には、bitcoin coreの機能も実装されていますが、ビットコインネットワークの利用などの多くの機能は、bitcoin core のRPC API を介して利用します。
* 使用する bitcoin coreのノードは、bitcoind でも. bitcoin-qt でもsnap のbitocoin-core でもよい
* 接続するビットコインネットワークによって、RPCで接続するポート番号が異なります。
* 以下ではsignetを想定します。
* signet でのRPCポートのデフォルトは、38332 です
* mainnet でのRPCポートのデフォルトは、8332 です

### irbで確認

ターミナルから Rubyインタプリタを起動

```bash
irb

> require 'bitcoin'
```

注意！　以下のエラーが出た場合（M1 Mac などで発生します）

```ruby
> require 'bitcoin'

Unable to load the EventMachine C extension; To use the pure-ruby reactor, require 'em/pure_ruby'
...
```

以下のようにすればエラーを回避できます

```ruby
> require 'em/pure_ruby'
=> true
> require 'bitcoin'
=> true
```

## bitcoinrb を使ったバイナリデータの処理

### OpenSSL::BNクラス (bitcoinrbに含まれています）

OpenSSL内で利用される暗号学的に利用される多倍長整数クラスです。
通常の通常多倍長整数の計算ではInteger クラスを使えばよいです。

ハッシュ値などのデータはOpenSSL::BNクラスのオブジェクトになります。


```ruby
# 2の18乗の10進数表現
2**18
=> 262144

# 16進数に変換
(2**18).to_s(16)
=> "40000"

# 整数を OpenSSL::BNクラスのオブジェクトに変換
(2**18).to_bn
=> #<OpenSSL::BN 262144>

# OpenSSL::BNクラスのオブジェクトを ビッグエンディアンの符号無し整数のバイナリ列に変換
(2**18).to_bn.to_s(2)
=> "\x04\x00\x00"

# さらにバイトオーダーを反転（リトルエンディアンにする）
(2**18).to_bn.to_s(2).reverse
=> "\x00\x00\x04"
```

### 16進数文字列と文字列や整数の pack unpack

* packメソッドは配列クラスのメソッドで，テンプレート文字列にしたがってバイナリ表現を文字列に変換する
* unpack メソットは文字列クラスのメソッドで，テンプレート文字列に従ってアンパックした配列に変換する
* テンプレート文字列の '*' は任意の長さの文字列パターンを意味する

```ruby
# 16進数の配列を（上位ニブル（4ビットのこと）が先）の16進数表現に変換(テンプレート文字列 H)
 ["000004"].pack("H*")
=> "\x00\x00\x04"

# 16進数文字列を16進数に変換する（上位ニブル（4ビットのこと）が先）(テンプレート文字列 H)
"\x00\x00\x04".unpack("H*")
=> ["000004"]
```

```ruby
# 10進数の整数を多倍長整数にして16進数リトルエンディアン表現にする
1440.to_bn.to_s(2).reverse.unpack("H*")[0]
=> "a005"
```

```ruby
# 8ビット符号なし整数に変換　(テンプレート文字列 C)
[1, 255].pack("C*") 
=> "\x01\xFF"

# 8ビット符号なし整数に変換　(テンプレート文字列 C)
"\x01\xFE".unpack("C*")
=> [1, 254]
```

### 便利な bitcoinrb のメソッド

* bth　メソッド

bitcoinrb では Stringクラスに16進数文字列で表現されたバイナリ表現から16進数に変換するメソッドが追加されています。

```ruby
# 16進数文字列で表現されたバイナリ表現
Bitcoin::sha256("hello")
=> ",\xF2M\xBA_\xB0\xA3\x0E&\xE8;*\xC5\xB9\xE2\x9E\e\x16\x1E\\\x1F\xA7B^s\x043b\x93\x8B\x98$"

 # bthメソッドで16進数に変換
 Bitcoin::sha256("hello").bth
=> "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"

# 整数をリトルエンディアンの16進数に変換する
1440.to_bn.to_s(2).reverse.bth
=> "a005"
```

* htbメソッド

bitcoinrb では Stringクラスに16進数から16進数文字列で表現されたバイナリ表現に変換するメソッドが追加されています。

```ruby
 "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824".htb
=> ",\xF2M\xBA_\xB0\xA3\x0E&\xE8;*\xC5\xB9\xE2\x9E\e\x16\x1E\\\x1F\xA7B^s\x043b\x93\x8B\x98$"
```

## 鍵生成

#### エントロピーからニーモニックコードを生成

安全な乱数生成装置からエントロピーを得て、ニーモニックコードの単語列を生成します

```ruby
entropy = SecureRandom.hex(32)
entropy
=> 
"e89cd62f38c5e2b56ad21134f1ca8f8596e8347c97930329cd02449bc124fbe7"

mnemonic = Bitcoin::Mnemonic.new('japanese')
word_list = mnemonic.to_mnemonic(entropy)
word_list
=>
["むしば", "みわく", "たなばた", "すべて", "さみしい", "さこく", "ないかく", "げきは", "きなこ", "たりる", "てんてき", "いたりあ", "すおどり", "えいえん", "ゆにゅう", "ゆびわ", "あてな", "ごかん", "けいさつ", "たくさん", "ねんれい", "ちあん", "やせる", "もちろん"]
```

ニーモニックコードの単語列をメモしてください

#### ニーモニックコードから鍵のシードを生成する

```ruby
seed = mnemonic.to_seed(word_list)
=>
"862d7f8b794d2ffbdd29861e519834f104763c5716ed4e2a8cf212e68f721ab2462ab3a2955ae0c50eb981d1b689ffba71be0e116124a4...

```

####  シードからマスターキーを生成する

```ruby
master_key = Bitcoin::ExtKey.generate_master(seed)
=>
 #<Bitcoin::ExtKey:0x00005627157cf118 @number=0, @depth=0, @parent_fingerprint="00000000", @key=#<Bitcoin::Key:0...
```

#### BIP84 のP2WPKH派生鍵を生成する

鍵派生

`m / purpose' / coin_type' / account' / change / address_index`

purpose＝84
coin_type=0(meinnet) / 1(testnet,signet)

```ruby
# m/84'/1'/0'/0/0
key = master_key.derive(84, true).derive(1, true).derive(0, true).derive(0).derive(0)
=> 
#<Bitcoin::ExtKey:0x0000562715395c00 @number=0, @depth=5, @parent_fingerprint="9db5eb4c", @key=#<Bitcoin::Key:0...
```

変数 key は Bitcoin::Keyクラスのオブジェクト

Bitcoin::Key オブジェクトから秘密鍵、公開鍵、アドレスを取り出す

```ruby
# 変数 key は Bitcoin::Keyクラスのオブジェクト

key.priv
=> 
"8d9092c7d8dd5effbc654b03c325afb30d989b8102846dfcf28b4f4d5ba42369"

key.pub
=> 
"031932b0c9c4c283236d738b67a2b18c3dbb65923db31f4601e9d90b31651b37f6"

key.addr
=> 
"tb1qvu9d36dyxzxvh0q743hzcjasq3kdyz7sjzaax7"
```

### UTXOの作成（事前作業）

faucet を利用するなどして、作成したアドレスに 0.0001 BTC 程度の資金を送金しておきます。

## bitcoin core RPC API の利用

signetを利用する場合です

```ruby
require 'bitcoin'
require 'net/http'
require 'json'
include Bitcoin
include Bitcoin::Opcodes

Bitcoin.chain_params = :signet

HOST="localhost"
PORT=38332          # mainnetの場合は 8332
RPCUSER="hoge"      # bitcoin core RPCユーザ名
RPCPASSWORD="hoge"  # bitcoin core パスワード

# bitcoin core RPC を利用するメソッド
def bitcoinRPC(method, params)
    http = Net::HTTP.new(HOST, PORT)
    request = Net::HTTP::Post.new('/')
    request.basic_auth(RPCUSER, RPCPASSWORD)
    request.content_type = 'application/json'
    request.body = { method: method, params: params, id: 'jsonrpc' }.to_json
    JSON.parse(http.request(request).body)["result"]
end
```


## トランザクション構成の基本


#### 使用するUTXOの選定

```ruby
# 現在のワレットが所持しているUTXOのリスト
utxos = bitcoinRPC('listunspent', [])

# ここではutxosの配列の最初のものを使用することにする
utxo=utxos[0]

utxo
=> 
{"txid"=>"77a2252e6d0a65ca269cb558f85f3e0ccbf0fcf32312560ca3a5530ab5347153",
 "vout"=>0,
 "address"=>"tb1qd6m8ke8kquz7nga6dan9ktnsx4em5zayvd7n89",
 "label"=>"",
 "scriptPubKey"=>"00146eb67b64f60705e9a3ba6f665b2e703573ba0ba4",
 "amount"=>0.09999858,
 "confirmations"=>9366,
 "spendable"=>true,
 "solvable"=>true,
 "desc"=>"wpkh([e4668231/0'/0'/13']03806dceecc97d25000d6047c9b72e39ca6cbe7fe6fa49a02b06f95103abb863ba)#em8vspdk",
 "safe"=>true}
```

#### UTXOを受領したアドレスの秘密鍵を得る

★注意
bitcoin core の createwallet コマンドでワレットを作成すると、デフォルトで descriptor walletsになります。

ワレットを descriptor wallets として作成した場合、 dumpprivkey で秘密鍵を取り出すことはできません。

事前に bitcoin coreのワレットを利用せずに自分で作成した鍵とアドレスを利用する場合、以下は必要ありません。

```ruby
# UTXOの受領者のアドレスの秘密鍵
privkey=bitcoinRPC('dumpprivkey', [utxo["address"]])

# 変数 key は Bitcoin::Keyクラスのオブジェクト
key = Bitcoin::Key.from_wif(privkey)

```

#### テスト用送金先アドレスの生成

```ruby
alice=bitcoinRPC('getnewaddress', [])
bob=bitcoinRPC('getnewaddress', [])
carol=bitcoinRPC('getnewaddress', [])
```

#### トランザクションのテンプレートの作成

```ruby
tx = Bitcoin::Tx.new
```

#### トランザクションのINPUTの作成

トランザクションのinputは、使用するUTXOへの参照（out_point) 
その内容は、トランザクションID(txid)とvoutの番号

```ruby
utxo_txid=utxo["txid"]
utxo_vout=utxo["vout"]

outpoint = Bitcoin::OutPoint.from_txid(utxo_txid, utxo_vout)
tx.in <<  Bitcoin::TxIn.new(out_point: outpoint)

```

#### トランザクションのoutputの作成

送金金額

```ruby
# UTXOの残高
utxo_amount = (utxo["amount"]*(10**8)).to_i
# 送金金額 0.0001 BTCとします
send_value=(0.0001*(10**8)).to_i
# 送金手数料
fee = 1000
# おつり
change=utxo_amount-send_value-fee
```

送金先 OUTPUT (送金先アドレスをaliceとします)

```ruby
script_pubkey0 = Bitcoin::Script.parse_from_addr(alice)
tx.out << Bitcoin::TxOut.new(value: send_value, script_pubkey: script_pubkey0)
```

おつり  OUTPUT (おつりの送付先アドレスを receipt_address とします)

```ruby
script_pubkey1 = Bitcoin::Script.parse_from_addr(receipt_address)
tx.out << Bitcoin::TxOut.new(value: change, script_pubkey: script_pubkey1)
```

#### 未署名のトランザクションの確認

```ruby
tx
=> 
#<Bitcoin::Tx:0x000055fb91c89960
 @inputs=
  [#<Bitcoin::TxIn:0x000055fb91c46d68
    @out_point=#<Bitcoin::OutPoint:0x000055fb91c4eab8 @index=0, @tx_hash="17880e76f15fbb126d5d7cf04fbe9bf9f1b9363dc5cd220581d052547b493f24">,
    @script_sig=#<Bitcoin::Script:0x000055fb91c46b88 @chunks=[]>,
    @script_witness=#<Bitcoin::ScriptWitness:0x000055fb91c44a40 @stack=[]>,
    @sequence=4294967295>],
 @lock_time=0,
 @outputs=
  [#<Bitcoin::TxOut:0x000055fb917688c8
    @script_pubkey=#<Bitcoin::Script:0x000055fb91728d90 @chunks=["\x00", "\x14\xEC\xDE-\x12\x88\xFE`\xD9j\x9E\x9D\xF6\xAAe\xF7\xDDqw\xBBO"]>,
    @value=100000>,
   #<Bitcoin::TxOut:0x000055fb91b635e0
    @script_pubkey=#<Bitcoin::Script:0x000055fb91751038 @chunks=["\x00", "\x14f\x1F\xE0\xDA;\xEA\x10]\x7F\x93L\xA9xC{\x8A\x19\v\xFE\xB2"]>,
    @value=6739730>],
 @version=1>
```

#### トランザクションへの署名 (P2WPKH)


inputのインデックスと参照先UTXOのscriptPubKey（ここではinput 0)

```ruby
input_index = 0
prev_scriptPubKey = Bitcoin::Script.parse_from_payload(utxo["scriptPubKey"].htb)
```

P2WPKHのトランザクションハッシュ値 

```ruby
sighash = tx.sighash_for_input(input_index,prev_scriptPubKey, sig_version: :witness_v0, amount: utxo_amount)
```

署名(SHIGHASH ALL)の作成

```ruby
sign = key.sign(sighash) + [Bitcoin::SIGHASH_TYPE[:all]].pack('C')
```

作成した署名と公開鍵をトランザクションのwitness領域に埋め込む

```ruby
tx.in[0].script_witness.stack << sign
tx.in[0].script_witness.stack << key.pubkey.htb
```

#### 署名されたトランザクションの確認

```ruby
tx
=> 
#<Bitcoin::Tx:0x000055fb91c89960
 @inputs=
  [#<Bitcoin::TxIn:0x000055fb91c46d68
    @out_point=#<Bitcoin::OutPoint:0x000055fb91c4eab8 @index=0, @tx_hash="17880e76f15fbb126d5d7cf04fbe9bf9f1b9363dc5cd220581d052547b493f24">,
    @script_sig=#<Bitcoin::Script:0x000055fb91c46b88 @chunks=[]>,
    @script_witness=
     #<Bitcoin::ScriptWitness:0x000055fb91c44a40
      @stack=
       ["0D\x02 \x11J\xBF\xAEa\x9E\x92{\xE73\xA102TS\x95A~Ms\x0F~\xD7\xE1o\xD8s\x7F\xCCJ\xE9A\x02 i\xDCl\x93\xC9\xEB\x8A\xDC'\x9BkH\xDBL\x1C\x01\v\xE1\xDD\xC13|\xB4\xAB\xD3K\xD0\xC8\x84\x97[\x8B\x01",
        "\x02\x993Q\x8Al\xA4\xD7\xD2\xD3\xD9\xF8\x90`R\xF3\x01\xB7\xC4\xF8e{\a\xF4*2\x16Yrf\x05\xA6\x14"]>,
    @sequence=4294967295>],
 @lock_time=0,
 @outputs=
  [#<Bitcoin::TxOut:0x000055fb917688c8
    @script_pubkey=#<Bitcoin::Script:0x000055fb91728d90 @chunks=["\x00", "\x14\xEC\xDE-\x12\x88\xFE`\xD9j\x9E\x9D\xF6\xAAe\xF7\xDDqw\xBBO"]>,
    @value=100000>,
   #<Bitcoin::TxOut:0x000055fb91b635e0
    @script_pubkey=#<Bitcoin::Script:0x000055fb91751038 @chunks=["\x00", "\x14f\x1F\xE0\xDA;\xEA\x10]\x7F\x93L\xA9xC{\x8A\x19\v\xFE\xB2"]>,
    @value=6739730>],
 @version=1>
```

#### トランザクションの検証

```ruby
tx.verify_input_sig(0, prev_scriptPubKey, amount: utxo_amount)

=> true
```

#### トランザクションを16進形式に変換

```ruby
tx.to_hex
=> "0100000000010117880e76f15fbb126d5d7cf04fbe9bf9f1b9363dc5cd220581d052547b493f240000000000ffffffff02a086010000000000160014ecde2d1288fe60d96a9e9df6aa65f7dd7177bb4f12d7660000000000160014661fe0da3bea105d7f934ca978437b8a190bfeb2024730440220114abfae619e927be733a13032545395417e4d730f7ed7e16fd8737fcc4ae941022069dc6c93c9eb8adc279b6b48db4c1c010be1ddc1337cb4abd34bd0c884975b8b0121029933518a6ca4d7d2d3d9f8906052f301b7c4f8657b07f42a321659726605a61400000000"
```

#### 作成したトランザクションの送信


```ruby
 result = bitcoinRPC('sendrawtransaction', [tx.to_hex])

```

#### txid, wtxid

```ruby
tx.txid
=> "2ebc46c062e5cccf6cbde9c4d76250bc8ec197bd854350837a73e87a353f4efb"

tx.wtxid
=> "2b363325aefac42d8a4fcb018b2a2ac0955e961e148d26992360d4e8a0f6f8a2"
```

### 課題

ここまでのプログラムを綜合し、送金金額と宛先アドレスを指定して P2WPKHトランザクションで送金するメソッドを作成してください。

* 送金金額が所持金残高を超えた場合はエラーにしてください
* 各UTXOの金額を綜合して、送金金額をぎりぎりうわまわるUTXOのリストを作成してください


## bitcoin スクリプトの基本

bitcoinにもプログラミングが行えるの機能が備わっています。
ここでは、bitcoinスクリプトによるプログラミングの基本を学びます。

#### スクリプトオブジェクトの生成

バイナリデータを解析して bitcoinrb のスクリプトオブジェクトを生成する

```ruby
script_b = Bitcoin::Script.parse_from_payload('76a91446c2fbfbecc99a63148fa076de58cf29b0bcf0b088ac'.htb)
```

スクリプトの文字列からbitcoinrb のスクリプトオブジェクトを生成する

```ruby
script_s = Bitcoin::Script.from_string('OP_DUP OP_HASH160 46c2fbfbecc99a63148fa076de58cf29b0bcf0b0 OP_EQUALVERIFY OP_CHECKSIG')
```

オペコードのスタックからbitcoinrb のスクリプトオブジェクトを生成する

```ruby
include Bitcoin::Opcodes
script_o = Bitcoin::Script.new << OP_DUP << OP_HASH160 << '46c2fbfbecc99a63148fa076de58cf29b0bcf0b0' << OP_EQUALVERIFY << OP_CHECKSIG
```

#### bitcoinスクリプトの評価

`6+1=7`　を計算してみます

```ruby
script = Bitcoin::Script.from_string('6 1 OP_ADD 7 OP_EQUAL')
script.run
=> true
```

#### スクリプトユーティリティ

* P2PKHスクリプトの生成

```ruby
# 公開鍵ハッシュ
script = Bitcoin::Script.to_p2pkh('46c2fbfbecc99a63148fa076de58cf29b0bcf0b0')
```

* P2WPKH

```ruby
# 公開鍵ハッシュ
script = Bitcoin::Script.to_p2wpkh('46c2fbfbecc99a63148fa076de58cf29b0bcf0b0')
```

* P2SH

```ruby
# redeem_script
p2sh = script.to_p2sh
```

* P2WSHマルチシグ

```ruby
#　閾値 m　と　公開鍵の配列
k1 = '021525ca2c0cbd42de7e4f5793c79887fbc8b136b5fe98b279581ef6959307f9e9'
k2 = '032ad705d98318241852ba9394a90e85f6afc8f7b5f445675040318a9d9ea29e35'
script = Bitcoin::Script.to_p2sh_multisig_script(1, [k1, k2])
```

* P2WSH

```ruby
# redeem_script
script = Bitcoin::Script.to_p2wsh(<redeem script>)
```

## Bitcoinの送金プログラムの例

現在の所持金のUTXOのリストから送金に必要なUTXOのリストを作成して送金する

```ruby
require 'bitcoin'
require 'net/http'
require 'json'
include Bitcoin
include Bitcoin::Opcodes

Bitcoin.chain_params = :signet

HOST="localhost"
PORT=38332          # mainnetの場合は 8332
RPCUSER="hoge"      # bitcoin core RPCユーザ名
RPCPASSWORD="hoge"  # bitcoin core パスワード
FEE = 0.00002       # 手数料

# bitcoin core RPC を利用するメソッド
def bitcoinRPC(method, params)
    http = Net::HTTP.new(HOST, PORT)
    request = Net::HTTP::Post.new('/')
    request.basic_auth(RPCUSER, RPCPASSWORD)
    request.content_type = 'application/json'
    request.body = { method: method, params: params, id: 'jsonrpc' }.to_json
    JSON.parse(http.request(request).body)["result"]
end

# Bitcoin送金メソッド
    # 送金先アドレス、送金金額

def send_bitcoin(addr, amount)
    # 所持金残高を確認
    balance = bitcoinRPC('getbalance', [])
    if balance < (amount+FEE) then
        puts "error (残高不足)"
    else
        # 送金金額＋手数料をぎりぎり上回るUTXOリストの作成
        utxos = consuming_utxos(amount+FEE)
        # 送金に使用するUTXOの総額
        fund = utxos.map{|utxo|utxo["amount"]}.sum
        # UTXOの総額 - 送金金額 - 手数料 = おつり
        change = fund-amount-FEE
        # おつり用アドレス（UTXOの０番目を受け取ったアドレスを利用する）
        addrChange = utxos[0]["address"]
        # トランザクションの構成（P2WPKH)
        tx = p2wpkh_transaction(addr, amount, utxos, change, addrChange)
        # トランザクションへの署名
        tx = sign_inputs(utxos, tx)
        # ビットコインネットワークへのデプロイ
        return bitcoinRPC('sendrawtransaction', [tx.to_hex])
    end
end


# P2WPKHトランザクションの構成

def p2wpkh_transaction(addr,amount, utxos, change, addrChange)
    # トランザクションのテンプレートの生成
    tx = Bitcoin::Tx.new
    # トランザクションのinputの構成
    tx = make_inputs(tx,utxos)
    # トランザクションのoutputの構成
    tx = make_outputs(tx,amount, addr, change, addrChange)
    return tx
end

# トランザクションのinputの構成

def make_inputs(tx, utxos)
    utxos.each{|utxo|
        # UTXOをinputから参照するための txid と vout としてエンコードする
        outpoint = Bitcoin::OutPoint.from_txid(utxo["txid"], utxo["vout"])
        # エンコードした参照をトランザクションのinputに埋め込む
        tx.in << Bitcoin::TxIn.new(out_point: outpoint)
    }
    return tx
end

# トランザクションのoutputの構成

def make_outputs(tx,amount, addr, change, addrChange)
    # 送金用outputの構成
        # 金額を satoshiの整数に変換
    amount_satoshi = (amount*(10**8)).to_i
        # ビットコインアドレスから p2wpkhのscript_pubkey を生成
    scriptPubKey0 = Bitcoin::Script.parse_from_addr(addr)
        # エンコードしたscript_pubkeyをトランザクションのoutputに埋め込む
    tx.out << Bitcoin::TxOut.new(value: amount_satoshi , script_pubkey: scriptPubKey0)
    # おつり用outputの構成
        # 金額を satoshiの整数に変換
    change_satoshi =  (change*(10**8)).to_i
        # ビットコインアドレスから p2wpkhのscript_pubkey を生成
    scriptPubKey1 = Bitcoin::Script.parse_from_addr(addrChange)
        # エンコードしたscript_pubkeyをトランザクションのoutputに埋め込む
    tx.out << Bitcoin::TxOut.new(value: change_satoshi, script_pubkey: scriptPubKey1)
    return tx
end

# トランザクションへの署名

def sign_inputs(utxos, tx)
    utxos.each.with_index{|utxo,index|
        # UTXOのscriptPubKey をオブジェクト化する
        script_pubkey = Bitcoin::Script.parse_from_payload(utxo["scriptPubKey"].htb)
        # scriptPubKey の送金先アドレス
        myaddr = script_pubkey.to_addr
        # UTXOの送付先アドレスの秘密鍵（署名鍵）
        priv = bitcoinRPC('dumpprivkey', [myaddr])
        # 署名鍵オブジェクト
        key = Bitcoin::Key.from_wif(priv)
        # UTXOの金額
        satoshi = (utxo["amount"]*(10**8)).to_i
        case script_pubkey.type
        when "witness_v0_keyhash"   # UTXOがP2WPKHタイプ
            # トランザクションのハッシュ値を計算
            sighash = tx.sighash_for_input(index, script_pubkey, sig_version: :witness_v0, amount: satoshi)
            # トランザクションへの署名＋署名タイプ情報を付加
            sig = key.sign(sighash) + [Bitcoin::SIGHASH_TYPE[:all]].pack('C')
            # witness scriptの追加
            tx.in[index].script_witness.stack << sig
            # 公開鍵の追加
            tx.in[index].script_witness.stack << key.pubkey.htb
        end
    }
    return tx
end

# 送金金額＋手数料をぎりぎり上回るUTXOリストの作成

def consuming_utxos(amount)
    # ワレットの未使用のUTXOの一覧を得る
    unspent = bitcoinRPC('listunspent', [])
    # 消費可能状態のUTXOの選定
    spendable_utxos = unspent.select{|t|t["spendable"]==true}
    # UTXOを金額で昇順にソートする
    sorted_utxos = spendable_utxos.sort_by{|x|x["amount"]}
    # 少額のUTXOから集めて，指定金額を上回るぎりぎりのUTXOのリストを作成する
    utxos=[]
    begin
        utxos << sorted_utxos.shift
        balance = utxos.reduce(0){|s,t|s+=t["amount"]}
    end until balance >= amount
    return utxos
end


# 送金のテスト
    # 引数は，送金先アドレス，送金金額，手数料


amount = 0.0001
alice=bitcoinRPC('getnewaddress', [])
    # 送金の実行。実行結果はトランザクションID
txid = send_bitcoin(alice, amount)
```
