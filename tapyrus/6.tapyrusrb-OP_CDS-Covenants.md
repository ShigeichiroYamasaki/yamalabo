# tapyrusrb OP_CDS によるCovenantsの実現

最終更新 2023/07/07 Shigeichiro Yamasaki

## bitcoinの課題

bitcoinスクリプトは，output の宛先や金額を参照することができない．
これは，スクリプトでスマートコントラクトを作成するときに問題になる．

例えば，スクリプトを使って，トランザクションの送金先やその金額を指定したい場合がそれに該当する．

```
    ---------------        ---------------
    |input |output|        |input |output| 
    |      | UTXO | -----> |      | 宛先  |
    |      | ロック|        |      | 金額  |
    ---------------        ---------------
               ↓              ↑     ↑
             P2SH  ------->   スクリプト
```

## Covenants

Covenantsは，スクリプトでトランザクションのアウトプットを検証することで、ロックされたUTXOの送金先や送金額などを自由に変更できないようにする方法．

オリジナルの bitcoin にはない，`OP_CDS (OP_CHECKDATASIG)` というオペコードの追加で Covenants が実現できるようになる．

#### OP_CDS

署名、メッセージおよび公開鍵を受け取り、メッセージに対する署名を検証する
Scriptの中でトランザクション以外のデータに対して署名の検証ができる

```
<sig> <msg> <pubKey> OP_CHECKDATASIG
```

* <sig> が <msg> <pubKey> で検証して成功すれば true になる

### OP_CDS の実験

#### 暗号鍵

```ruby
require 'tapyrus'
require 'json'
require "open3"
include Tapyrus
include Tapyrus::Opcodes
FEE = 0.00002       # 手数料
Tapyrus.chain_params = :prod
# tapyrus-cli コマンドのフルパス
Tapyrus_cli ='~/tapyrus-core-0.5.2/bin/tapyrus-cli'
# RPC
def tapyrusRPC(method,params)
    r=Open3.capture3("#{Tapyrus_cli} #{method} #{params.join(' ')}")
    if r[1] == "" then
        begin
            return JSON.parse(r[0])
        rescue JSON::ParserError
            return r[0]
        end
    else
        return r[1]
    end
end
# テスト用アカウントと鍵
mnemonic = Tapyrus::Mnemonic.new('english')
word_list =["ozone", "bounce", "hurdle", "weird", "token", "exclude", "remember", "swear", "knife", "bitter", "blossom", "horn", "repair", "aspect", "girl", "merit", "palace", "boring", "pottery", "relax", "sunset", "lucky", "elephant", "ticket"]
seed = mnemonic.to_seed(word_list)
master_key = Tapyrus::ExtKey.generate_master(seed)
# derive path 'm/0H'
key = master_key.derive(0, true)
#  鍵オブジェクト
keyAlice = key.derive(1)
# テスト用の秘密鍵
priv_alice = keyAlice.priv
## アドレス
alice = keyAlice.addr
# 公開鍵
pub_alice = keyAlice.pub
# 自分のワレットの秘密鍵をインポート
tapyrusRPC('importprivkey',[keyAlice.key.to_wif])
```

#### メッセージへの署名

```ruby
# メッセージ
msg='hello'

# 署名
sign=keyAlice.key.sign_data(msg)
=> "0D\x02 -\xCC\x15\x04%\xBD\xAF\xE0\xB7\xA4U\xEB\x8C\\_E\xD5\x13\x92.\xD7W@\x16\xC2\xB5\n\xFE2k\xB8%\x02 3\xE3\xEA\x9E\xA7\x96M\xC2\x1A\xFD\bM\xD8N\x04z;a\xCF\x82\xA4\x97\x95\xD8z\x9C\xDA\x9F\xD4x\xB5\x89"

# 公開鍵
pub_alice
=> "02a333e0b6f503c2fa6df50b41f9775c95e5c47012d7cdbb5d86ef7441d693cf65"
```
#### OP_CHECKDATASIG

失敗している

```ruby
script=Tapyrus::Script.new << sign << msg.bth << pub_alice << OP_CHECKDATASIG
script.run
=> false
```

#### デバッガで確認

```ruby
script_pubkey = (Tapyrus::Script.new  << msg << pub_alice << OP_CHECKDATASIG).to_hex
=> "0568656c6c6f2102a333e0b6f503c2fa6df50b41f9775c95e5c47012d7cdbb5d86ef7441d693cf65ba"

script_sig = (Tapyrus::Script.new << sign).to_hex
script_sig = sign
=> "463044022079a3a7e961017482e5d94967ec36ce919687329c0aa2ac6f812f103c52b54c0a0220086dbc6fabfbcb19b1f27132b5d928b15b14c01ace20d1c5b1"  
```

デバッガ

```bash
```

### Covenants の実現方法

* UTXO は P2SH (Covenants) でロックされている．（単純化のため，ロックされた金額は一定とする）
* このUTXOをアンロックするトランザクションのテンプレート（未署名）をシリアライズする → これを **preimage** と呼ぶ
* このアンロックトランザクションの output には指定する送金先や金額が入っている．
* `<msg>` をこの preimage にし，`<sig>` を preimage への署名とする
* 実際に UTXO をアンロックするトランザクションを作成する
  * アンロックトランザクションの output は，指定するアドレスと金額にする（`<preimage>` と同じ構造のトランザクションになる）
  * redeem Script の内容
    1. `OP_CHECKSIG` で `<pubKey>` と `<sig>` を使いトランザクションを検証
    2. `OP_CDS` で `<pubKey>` と `<sig>` を使い `<preimage>` を検証
    3. `<preimage>` の送金先と金額を検証


#### preimage のシリアライズ方法

署名対象をトランザクションの output 部分に限定し，トランザクションの署名対象を

|     フィールド                    |  内容                      |
|:--                       | :--                    |
|nVersion  |(4-byte little endian)|
|hashPrevouts |(32-byte hash)|
|nSequence |(32-byte)|
|outpoint |(32-byte hash + 4-byte little endian)|
|scriptCode of the input |(serialized as scripts inside CTxOuts)|
|value of the output |(8-byte little endian)|
|nSequence of the input |(4-byte little endian)|
|hashOutputs |(32-byte hash)|
|nLocktime  |(4-byte little endian)|
|sighash type of the signature| (4-byte little endian)|
