# 5. ERC20 トークンの作成と利用

OpenZeppelin のライブラリを利用した ERC20トークンを処理するコントラクト

最終更新 2024/10/30 Shigeichiro Yamasaki

## ERC-20の仕様

[ERC-20: Token Standard](https://eips.ethereum.org/EIPS/eip-20)

### ERC-20 のメソッド

* name 
  * トークンの名前を返す
  * `function name() public view returns (string)`
* symbol
  * トークンのシンボルを返す
  * `function symbol() public view returns (string)`
* decimals
  * トークンが使用する 10進数の小数点以下の桁数を返す
  * `function decimals() public view returns (uint8)`
* totalSupply
  * トークンの総供給量を返す
  * `function totalSupply() public view returns (uint256)`
* balanceOf
  * アドレスのアカウントが所有しているトークンの残高を返す
  * `function balanceOf(address _owner) public view returns (uint256 balance)`
* transfer
  * 金額 _value のトークンを _to のアドレスに送る
  * `function transfer(address _to, uint256 _value) public returns (bool success)`
* transferFrom
  * 代理で _from アドレスから _to アドレス宛に金額 _value のトークンを送る
  * `function transferFrom(address _from, address _to, uint256 _value) public returns (bool success)`
* approve
  * _spender アドレスのアカウントに対して _value で指定した金額まで複数回引き出すことを承認する
  * `function approve(address _spender, uint256 _value) public returns (bool success)`
* allowance
  * _spender アドレスのアカウントが _owner アドレスの所有者のアカウントから引き出し可能な残高を返す
  * `function allowance(address _owner, address _spender) public view returns (uint256 remaining)`

### ERC-20 のイベント

* Transfer
  * トークンが転送されたときにトリガされる．新規トークンを生成したときには  _from アドレスに 0x0 をセットする
  * `event Transfer(address indexed _from, address indexed _to, uint256 _value)`
* Approval
  * approve が成功したときにトリガされる．
  * `event Approval(address indexed _owner, address indexed _spender, uint256 _value)`

## ERC-20 トークンの送金 (transfer)

* コントラクトアカウントのストレージで（key,値）構造で管理される
  * 主キーは，所有者のアドレス
  * 値は，所有者ごとのトークンの残高
* トークンの送金は，送金者と受領者の保有残高の更新
  * ETHの保有は影響しない（ガス代は必要）
  
## ERC-20 の代理送金 (approve/tranferFrom)

* トークン保有者が自分のトークンの送金権限を別のアドレスに移譲することができる
  * スマートコントラクトによるトークンの販売などに利用される
* 承認 (approve)の利用例
  * トークン保有者が承認者で
  * トークン販売コントラクトにトークンの代理送金を承認する
* 代理送金（tranferFrom）の例
  * トークン販売コントラクトに Eth でトークン購入金額が入金されると
  * トークン販売コントラクトが購入者にトークンを代理送金する


## OpenZeppelin のERC20 ライブラリ

* OpenZeppelin のAPIサイト

[https://docs.openzeppelin.com/contracts/4.x/erc20](https://docs.openzeppelin.com/contracts/4.x/erc20)


## hardhat プロジェクトの初期化

```bash
sudo apt update
sudo apt upgrade -y
```

## hardhat プロジェクトの初期構成

* ERC20 用プロジェクト・ディレクトリ

```bash
cd ~/hardhat
mkdir erc20
cd erc20
```

* node.js プロジェクトの初期化と hardhat のインストール

```bash
npm init
npm install --save-dev hardhat
```

* hardhat プロジェクトの初期化

```bash
npx hardhat init
```

* ▶ Create a JavaScript project を選択（キーボードの矢印キーを使って）

* 生成されたディレクトリの確認

```bash
 tree -L 1
.
├── README.md
├── contracts
├── hardhat.config.js
├── ignition
├── node_modules
├── package-lock.json
├── package.json
└── test
```

* サンプルプログラムの削除

```bash
rm contracts/Lock.sol
rm test/Lock.js
rm ignition/modules/Lock.js
```

## hardhat へのOpenZeppelin のライブラリのインストール

プロジェクトルートに移動してへのOpenZeppelinコントタクトのモジュールをインストール

```bash
npm install  --save-dev @openzeppelin/contracts
```

## ERC-20 コントラクトの作成

* ここでは，仮にトークン名を JPQ としますが，好きな名前にしてください

```bash
nano contracts/JPQ.sol
```

このコントラクトは、name、symbol、initialSupply（初期供給量）を引数に取り、デプロイ時にトークンの全量をデプロイアドレスにミントします。

以下のコントラクトは，OpenZeppelin のサンプルを利用しています．
[https://docs.openzeppelin.com/contracts/4.x/erc20](https://docs.openzeppelin.com/contracts/4.x/erc20)

* コントラクトの継承とコンストラクタの間接的初期化

OpenZeppelin の ERC20 コントラクトを継承して新しいコントラクトを定義するが，そのコンストラクタでは親コントラクトの初期化も必要になる

```js
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract JPQ is ERC20 {
  // ERC20 コントラクトのコンストラクタ(name, symbol,decimals)
    constructor(uint256 initialSupply) ERC20("stable coin for JPY", "JPQ") {
        _mint(msg.sender, initialSupply);
    }
}

```

## hardhat node の起動


### hardhat設定ファイル hardhat.config.js の修正

* ネットワークを hardhat networkにする
* チェインIDを 31337
* マイニングの間隔を10秒に設定

```bash
nano hardhat.config.js
```

```js
require("@nomicfoundation/hardhat-toolbox");

/** @type import('hardhat/config').HardhatUserConfig */
module.exports = {
  solidity: "0.8.27",
  networks: {
    hardhat: {
      chainId: 31337,
      mining: {
        auto: false,
        interval: [10000, 11000]
      }
    },
  },
};
```

### ローカルノードの起動

```bash
npx hardhat node
```

## デプロイスクリプト

* 別のターミナルを開いて
* scripts ディレクトリを作成して deploy スクリプトを作成する

```bash
cd ~
cd hardhat/erc20

mkdir scripts

nano scripts/deploy.js

```

```js
const hre = require("hardhat");

async function main() {
  const [deployer] = await hre.ethers.getSigners();
  console.log("デプロイ主体のアカウント:", deployer.address);

  // トークン名，トークンの総供給量を指定してコントラクトをデプロイする
  const JPQ = await hre.ethers.deployContract("JPQ",[10000]);
  await JPQ.waitForDeployment();

  console.log("オーナー:", JPQ.address);
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
```

### ローカルノードへのデプロイ

```bash
npx hardhat run scripts/deploy.js --network localhost
```

* ログの確認

コントラクトアドレスを確認する

```js
Mined block #15
  Block: 0xfe411f3055b0a05ae0631c62e22cf5eb912697ff0f21a5eb549ffc0a6f78fd0e
    Base fee: 134933816
    Transaction:           0x3e5ea77d415262ee437ff2615bc26d29d6aa2afa3b9320d0ba5bd6f18329975b
      Contract deployment: JPQ
      Contract address:    0x5fbdb2315678afecb367f032d93f642f64180aa3
      From:                0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266
      Value:               0 ETH
```
## コンソールからの操作

### コンソールの起動

```bash
npx hardhat console --network localhost 
```

### ERC20 コントラクトへの操作

```js
> const contract_addr = "0x5fbdb2315678afecb367f032d93f642f64180aa3"

> const factory = await ethers.getContractFactory("JPQ")

// 当該コントラクトアドレスのコントラクトに接続する
> const contract = await factory.attach(contract_addr)

// EOAのアドレス
> const [owner, addr1, addr2] = await ethers.getSigners();

// トークンの総供給量
> await contract.totalSupply()
10000n
// owner のトークン保有量
> await contract.balanceOf(owner)
10000n
```

* トークンの送付

```js
> await contract.transfer(addr1,80)

ContractTransactionResponse {
  provider: HardhatEthersProvider {
    _hardhatProvider: LazyInitializationProviderAdapter {
      _providerFactory: [AsyncFunction (anonymous)],
      _emitter: [EventEmitter],
      _initializingPromise: [Promise],
      provider: [BackwardsCompatibilityProviderAdapter]
    },
    _networkName: 'localhost',
    _blockListeners: [],
    _transactionHashListeners: Map(0) {},
    _eventListeners: []
  },
  blockNumber: null,
  blockHash: null,
  index: undefined,
  hash: '0xbc2b76de415a4f011281bfff230f5e61940948bbfd1ad74d95f9f1bd59c89708',
  type: 2,
  to: '0x5FbDB2315678afecb367f032d93F642f64180aa3',
  from: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
  nonce: 1,
  gasLimit: 30000000n,
  gasPrice: 1000029309n,
  maxPriorityFeePerGas: 1000000000n,
  maxFeePerGas: 1000029309n,
  maxFeePerBlobGas: null,
  data: '0xa9059cbb00000000000000000000000070997970c51812dc3a010c7d01b50e0d17dc79c80000000000000000000000000000000000000000000000000000000000000050',
  value: 0n,
  chainId: 31337n,
  signature: Signature { r: "0x8dae5f316cb297fda990307e413eb54cfc1a2ab5f79e9ee2175e1c70e44d6588", s: "0x0babb59232476fb837d549135d61f8d9ac97d758501a31c20b63014e9167f191", yParity: 0, networkV: null },
  accessList: [],
  blobVersionedHashes: null
}
```

* アカウントのトークン保有残高の確認

```js
> await contract.balanceOf(owner)
9920n
> await contract.balanceOf(addr1)
80n
```

## ERC20を利用するコントラクト

###  Eth でトークンを販売するコントラクト

1.	トークン購入者はETHを支払い、トークンを受け取る。
2.	トークンの売り手は、コントラクトが指定する量のトークンをtransferFrom関数を使って購入者に送る。
3.	レートは1ETHあたりのトークン量として決めます。

```bash
nano contracts/TokenSale.sol
```

```js
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// JPQ(ERC20)コントラクトを利用するためのインターフェース定義
interface JPQ {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}
// トークン販売コントラクト
contract TokenSale {
    JPQ public token;
    address public seller;
    uint256 public rate; // 1 ETHあたりのトークン数
    // _token:JPQコントラクト，_seller:販売者, _rate:交換比率
    constructor(JPQ _token, address _seller, uint256 _rate) {
        token = _token;
        seller = _seller;
        rate = _rate;
    }

    function buyTokens() public payable {
        require(msg.value > 0, "ETH must be greater than 0");

        // 購入トークン量の計算
        uint256 tokenAmount = msg.value * rate;

        // 売り手に十分なトークンがあるか確認
        require(token.balanceOf(seller) >= tokenAmount, "Seller does not have enough tokens");

        // 売り手から購入者へのトークン送信
        require(token.transferFrom(seller, msg.sender, tokenAmount), "Token transfer failed");
    }

    // 売り手がETHを引き出すための関数
    function withdrawETH() public {
        require(msg.sender == seller, "Only seller can withdraw");
        payable(seller).transfer(address(this).balance);
    }
}
```

* コンパイル

```bash
npx hardhat compile
```

### デプロイスクリプト

```bash
nano scripts/deploy.js
```

```bash
const hre = require("hardhat");

async function main() {
  const [deployer] = await hre.ethers.getSigners();
  console.log("デプロイ主体のアカウント:", deployer.address);

  // トークン名，トークンの総供給量を指定してコントラクトをデプロイする
  const JPQ = await hre.ethers.deployContract("JPQ",[10000]);
  await JPQ.waitForDeployment();
  console.log("JPQのオーナー:", JPQ.address);

  // トークン販売コントラクトをデプロイする
  //    (1ETH = 408000円 = 408000JPQ)
  const TokenSale = await hre.ethers.deployContract("TokenSale",[deployer.address, 408000]);
  await TokenSale.waitForDeployment();
  console.log("TokenSaleのオーナー:", TokenSale.address);
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });

```

### ローカルノードへのデプロイ

```bash
npx hardhat run scripts/deploy.js --network localhost
```
