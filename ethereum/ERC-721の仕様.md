# EIP-721: Non-Fungible Token Standard 

2022/07/05 修正Shigeichiro Yamasaki


[EIP-721: Non-Fungible Token Standard ](https://eips.ethereum.org/EIPS/eip-721)

### 簡単な要約

deed(不動産などの権利証)とも呼ばれる、代替不可能トークン(non-fungible tokens)に対する標準インターフェースです。

#### 概要

この標準の目的は、スマートコントラクトによるNFTに対する標準APIを実装可能にすることです。
この標準はNFTの追跡や転送のための基本機能を提供します。

個人によるNFTの所有や取引のユースケースだけでなく、サードパーティのブローカー/ウォレット/オークション参加者（オペレーター）のユースケースについても検討しています。

NFTは、デジタルデータや有体物の資産の所有権を表示することができます。
私たちは世界に存在する多様な資産について検討しました、そして人々はもっと多くのことを夢見るだろうということも私たちは知っています：

* 物的資産： 不動産、美術品
* 仮想収蔵品：子猫の写真、収集可能なカード
* 「負の資産」：ローン、負債など

一般的に、すべての不動産はそれぞれ固有の存在です。2匹の子猫も同じではありません。
したがってNFTは個々に区別可能であり、それぞれの所有権を個別に追跡できる必要があります。

#### 動機

このインターフェース仕様の標準化により、ウォレット/ブローカー/オークションアプリケーションはイーサリアム上の任意のNFTと連携できるようになります。
シンプルなERC-721スマートコントラクトと、任意の数のNFTを追跡するコントラクトを提供します。追加のアプリケーションについては、以下で説明します。

この規格は、ERC-20トークン規格から着想を得ており、EIP-20が作成されてから2年の経験に基づいています。
EIP-20は、NFTを追跡するには不十分です。これは、各資産が個別である（代替不可能）のに対し、トークンの数量はそれぞれ同一である（代替可能）ためです。
この規格とEIP-20の違いを以下で検討します。

#### 仕様

このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、「OPTIONAL」は次のとおりです。 RFC2119で説明されているように解釈されます。

すべてのERC-721準拠のコントラクトでは、ERC721およびERC165インターフェースを実装する必要があります（以下の「警告」が適用されます）。

```js
pragma solidity ^0.4.20;

/// @title ERC-721 Non-Fungible Token Standard
/// @dev See https://eips.ethereum.org/EIPS/eip-721
///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.
interface ERC721 /* is ERC165 */ {
    /// @dev This emits when ownership of any NFT changes by any mechanism.
    ///  This event emits when NFTs are created (`from` == 0) and destroyed
    ///  (`to` == 0). Exception: during contract creation, any number of NFTs
    ///  may be created and assigned without emitting Transfer. At the time of
    ///  any transfer, the approved address for that NFT (if any) is reset to none.
    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);

    /// @dev This emits when the approved address for an NFT is changed or
    ///  reaffirmed. The zero address indicates there is no approved address.
    ///  When a Transfer event emits, this also indicates that the approved
    ///  address for that NFT (if any) is reset to none.
    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);

    /// @dev This emits when an operator is enabled or disabled for an owner.
    ///  The operator can manage all NFTs of the owner.
    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);

    /// @notice Count all NFTs assigned to an owner
    /// @dev NFTs assigned to the zero address are considered invalid, and this
    ///  function throws for queries about the zero address.
    /// @param _owner An address for whom to query the balance
    /// @return The number of NFTs owned by `_owner`, possibly zero
    function balanceOf(address _owner) external view returns (uint256);

    /// @notice Find the owner of an NFT
    /// @dev NFTs assigned to zero address are considered invalid, and queries
    ///  about them do throw.
    /// @param _tokenId The identifier for an NFT
    /// @return The address of the owner of the NFT
    function ownerOf(uint256 _tokenId) external view returns (address);

    /// @notice Transfers the ownership of an NFT from one address to another address
    /// @dev Throws unless `msg.sender` is the current owner, an authorized
    ///  operator, or the approved address for this NFT. Throws if `_from` is
    ///  not the current owner. Throws if `_to` is the zero address. Throws if
    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function
    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls
    ///  `onERC721Received` on `_to` and throws if the return value is not
    ///  `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.
    /// @param _from The current owner of the NFT
    /// @param _to The new owner
    /// @param _tokenId The NFT to transfer
    /// @param data Additional data with no specified format, sent in call to `_to`
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;

    /// @notice Transfers the ownership of an NFT from one address to another address
    /// @dev This works identically to the other function with an extra data parameter,
    ///  except this function just sets data to "".
    /// @param _from The current owner of the NFT
    /// @param _to The new owner
    /// @param _tokenId The NFT to transfer
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;

    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE
    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE
    ///  THEY MAY BE PERMANENTLY LOST
    /// @dev Throws unless `msg.sender` is the current owner, an authorized
    ///  operator, or the approved address for this NFT. Throws if `_from` is
    ///  not the current owner. Throws if `_to` is the zero address. Throws if
    ///  `_tokenId` is not a valid NFT.
    /// @param _from The current owner of the NFT
    /// @param _to The new owner
    /// @param _tokenId The NFT to transfer
    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;

    /// @notice Change or reaffirm the approved address for an NFT
    /// @dev The zero address indicates there is no approved address.
    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized
    ///  operator of the current owner.
    /// @param _approved The new approved NFT controller
    /// @param _tokenId The NFT to approve
    function approve(address _approved, uint256 _tokenId) external payable;

    /// @notice Enable or disable approval for a third party ("operator") to manage
    ///  all of `msg.sender`'s assets
    /// @dev Emits the ApprovalForAll event. The contract MUST allow
    ///  multiple operators per owner.
    /// @param _operator Address to add to the set of authorized operators
    /// @param _approved True if the operator is approved, false to revoke approval
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice Get the approved address for a single NFT
    /// @dev Throws if `_tokenId` is not a valid NFT.
    /// @param _tokenId The NFT to find the approved address for
    /// @return The approved address for this NFT, or the zero address if there is none
    function getApproved(uint256 _tokenId) external view returns (address);

    /// @notice Query if an address is an authorized operator for another address
    /// @param _owner The address that owns the NFTs
    /// @param _operator The address that acts on behalf of the owner
    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);
}

interface ERC165 {
    /// @notice Query if a contract implements an interface
    /// @param interfaceID The interface identifier, as specified in ERC-165
    /// @dev Interface identification is specified in ERC-165. This function
    ///  uses less than 30,000 gas.
    /// @return `true` if the contract implements `interfaceID` and
    ///  `interfaceID` is not 0xffffffff, `false` otherwise
    function supportsInterface(bytes4 interfaceID) external view returns (bool);
}
```

ウォレット/ブローカー/オークションアプリケーションは、安全な転送を受け入れる場合、wallet interface を実装する必要があります(MUST)。

```js
/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.
interface ERC721TokenReceiver {
    /// @notice Handle the receipt of an NFT
    /// @dev The ERC721 smart contract calls this function on the recipient
    ///  after a `transfer`. This function MAY throw to revert and reject the
    ///  transfer. Return of other than the magic value MUST result in the
    ///  transaction being reverted.
    ///  Note: the contract address is always the message sender.
    /// @param _operator The address which called `safeTransferFrom` function
    /// @param _from The address which previously owned the token
    /// @param _tokenId The NFT identifier which is being transferred
    /// @param _data Additional data with no specified format
    /// @return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`
    ///  unless throwing
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4);
}
```

 metadata extension は、ERC-721スマートコントラクトではオプションです（以下の「警告」を参照）。
これにより、スマートコントラクトに、その名前とNFTが表す資産の詳細について問い合わせることができます。

```js
/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension
/// @dev See https://eips.ethereum.org/EIPS/eip-721
///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.
interface ERC721Metadata /* is ERC721 */ {
    /// @notice A descriptive name for a collection of NFTs in this contract
    function name() external view returns (string _name);

    /// @notice An abbreviated name for NFTs in this contract
    function symbol() external view returns (string _symbol);

    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.
    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC
    ///  3986. The URI may point to a JSON file that conforms to the "ERC721
    ///  Metadata JSON Schema".
    function tokenURI(uint256 _tokenId) external view returns (string);
}
```

以下は、上で参照した「ERC721メタデータのJSONスキーマ」です。


```js
{
    "title": "Asset Metadata",
    "type": "object",
    "properties": {
        "name": {
            "type": "string",
            "description": "Identifies the asset to which this NFT represents"
        },
        "description": {
            "type": "string",
            "description": "Describes the asset to which this NFT represents"
        },
        "image": {
            "type": "string",
            "description": "A URI pointing to a resource with mime type image/* representing the asset to which this NFT represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive."
        }
    }
}
```

enumeration extension は、ERC-721スマートコントラクトではオプションです（以下の「警告」を参照）。
これにより、コントラクトでNFTの完全なリストを公開し、それらを検出可能にすることができます。

```js
/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
/// @dev See https://eips.ethereum.org/EIPS/eip-721
///  Note: the ERC-165 identifier for this interface is 0x780e9d63.
interface ERC721Enumerable /* is ERC721 */ {
    /// @notice Count NFTs tracked by this contract
    /// @return A count of valid NFTs tracked by this contract, where each one of
    ///  them has an assigned and queryable owner not equal to the zero address
    function totalSupply() external view returns (uint256);

    /// @notice Enumerate valid NFTs
    /// @dev Throws if `_index` >= `totalSupply()`.
    /// @param _index A counter less than `totalSupply()`
    /// @return The token identifier for the `_index`th NFT,
    ///  (sort order not specified)
    function tokenByIndex(uint256 _index) external view returns (uint256);

    /// @notice Enumerate NFTs assigned to an owner
    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if
    ///  `_owner` is the zero address, representing invalid NFTs.
    /// @param _owner An address where we are interested in NFTs owned by them
    /// @param _index A counter less than `balanceOf(_owner)`
    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,
    ///   (sort order not specified)
    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);
}
```

#### 注意

0.4.20 Solidityインターフェースの文法は、ERC-721標準を実装するために十分な表現力がありません。
ERC-721に準拠するコントラクトは、以下にも従わなければなりません(MUST)。

* Solidityの問題＃3412：上記のインターフェースには、各関数の明示的な更新可能性への保証レベルが含まれます。更新可能性の保証レベルは、弱いものから強いものの順に payable, implicit nonpayable, view, pureの順です。実装はこのインターフェースの更新可能性の保証を満たさなければならず(MUST)、より強力な保証レベルが必要となる場合もあります(MAY)。たとえば、payableのインターフェイスの関数は、コントラクトで支払い不可（状態の更新可能性が指定されていない）として実装される場合があります。今後のSolidityリリースでは、より厳密なコントラクトをこのインターフェイスから継承できるようになると予想されますが、バージョン0.4.20での回避策は、このインターフェイスを編集して、コントラクトから継承する前に、より厳密な更新可能性を追加することです。
* Solidityの問題＃3419：ERC721Metadata や ERC721Enumerable を実装するコントラクトは、ERC721も実装しなけらばならない(SHALL)。ERC-721の実装には、ERC-165の要件となるインターフェイスが含まれます。ERC721EnumerableERC721]
* Solidityの問題＃2330：仕様としてexternalと示される関数は、そのコントラクトが public な可視性のものとして使用されることを許容することになります。バージョン0.4.20の回避策として、インターフェースを編集して、コントラクトから継承する前にpublicに切り替えることができます。
* Solidityの問題＃3494、＃3544：this.*.selector　はSolidityによって警告としてマークされてますが、Solidityの将来のバージョンではこれをエラーとしてマークしません。


新しいバージョンのSolidityで警告をコードで表現できる場合は、このEIPを更新して警告を削除することができます。これは、元の仕様と同等です。

### 理論的根拠

識別可能な資産の追跡を必要とするイーサリアムスマートコントラクトにはたくさんの提案がありました。
既存または計画中のNFTの例としては、DecentralandのLAND、CryptoPunksの名を冠したpunks、DMarketやEnjinCoinなどのシステムを使用したゲーム内アイテムがあります。
将来の用途には、不動産などの実世界の資産の追跡が含まれます（UbitquityやPropyなどの企業が想定しているように）。これらの各ケースでは、これらのアイテムが元帳の数値として「まとめられ」ないことが重要ですが、代わりに、各資産の所有権を個別にアトミックに追跡する必要があります。これらの資産の性質に関係なく、部門の枠を超えた資産管理および販売プラットフォームを可能にする標準化されたインターフェースがあれば、エコシステムはより強力になります。

#### “NFT”という用語の選択

「NFT」は、調査対象のほぼすべての人にとって満足のいくものであり、識別可能なデジタル資産の幅広い領域に広く適用できます。「権利証(deed)」は、この規格の特定のアプリケーション（特に物理的特性）を非常によく説明するものであると認識しています。

考慮される代替案：識別可能な資産、タイトル、トークン、資産、資本、チケット

#### NFT Identifiers

すべてのNFTはuint256の、ERC-721スマートコントラクト内の一意のIDによって識別されます。この識別番号は、コントラクト期間中は変更されないものとします。その場合、ペア(contract address, uint256 tokenId)は、イーサリアムチェーン上の特定のアセットのグローバルに一意で完全に修飾された識別子になります。一部のERC-721スマートコントラクトはID0から始めて、新しいNFTごとに1ずつ増やすと便利な場合がありますが、発信者はID番号に特定のパターンがあると想定してはならず、IDを「ブラックボックス」として扱わなければなりません。 」。また、NFTが無効になる（破棄される）可能性があることにも注意してください。サポートされている列挙型インターフェースについては、列挙型関数を参照してください。

UUIDとsha3ハッシュは直接に変換できるため、を選択するとuint256、さまざまなアプリケーションが可能になりますuint256。

#### 転送メカニズム

ERC-721では、安全な転送関数 safeTransferFrom（bytesパラメーターの有無にかかわらず負荷が高い）と安全でない転送関数 transferFrom を標準化しています。転送は次の方法で開始できます。

* NFTの所有者
* そのNFTの公開アドレス (approved address of an NFT)
* NFTの現在の所有者として認可された主体

さらに、認可された主体は、NFTの公開アドレスを設定できます。これにより、ウォレット、ブローカー、オークションアプリケーションに強力なツールセットが提供され、多数のNFTをすばやく使用できます。

転送および受け入れ関数のドキュメントは、トランザクションがスローしなければならない条件のみを指定します。あなたの実装は他の状況でも投げることができます。これにより、実装は興味深い結果を達成できます。

* スマートコントラクトが一時停止されている場合は転送を禁止する    —先行技術、CryptoKitties展開コントラクト、行611
* NFTの受信から特定のアドレスをブロックリストする —先行技術、CryptoKitties展開コントラクト、行565、566
* 安全でない転送を禁止する  —等しいか、ゼロ以外であるか、以前はゼロ以外であった場合transferFromを除いてスローします（このような場合は安全であるため）_tomsg.sendercountOf(_to)
* トランザクションの両方の当事者に料金を請求します approve  —以前がゼロアドレスだった場合はゼロ以外で呼び出す場合は支払いを要求し、_approved以前はゼロ以外のアドレスであった場合はゼロアドレスで呼び出す場合は支払いを返金approveします。転送機能、転送パラメータ_toが等しいmsg.sender必要があり、転送パラメータ_toがNFTの承認済みアドレスである必要があります
* 読み取り専用NFTレジストリsafeTransferFrom—常に、、、およびtransferFromからスローしますapprovesetApprovalForAll


失敗したトランザクションはスローされます。これは、ERC-223、ERC-677、ERC-827、およびOpenZeppelinによるSafeERC20.solの実装で特定されたベストプラクティスです。ERC-20はallowance機能を定義しました。これにより、OpenZeppelinの問題＃438のように、呼び出されて後で別の量に変更されると問題が発生しました。ERC-721では、すべてのNFTが一意であり、数量がゼロまたは1であるため、許容値はありません。したがって、後で発見された問題なしに、ERC-20の元の設計の利点を享受できます。

NFTの作成（「ミンティング」）およびNFTの破棄（「焼却」）は、仕様に含まれていません。あなたのコントラクトは他の手段でこれらを実行するかもしれません。eventNFTを作成または破棄するときの責任については、ドキュメントを参照してください。

operatoronのパラメータonERC721Receivedが必要かどうか質問しました。すべての場合において、オペレーターが重要である場合、そのオペレーターはトークンを自分自身に転送してから送信することができ、それがfromアドレスになります。これは、オペレーターがトークンの一時的な所有者であると見なすために考案されたようです（そして、オペレーター自身への転送は冗長です）。オペレーターがトークンを送信するとき、それはトークン所有者に代わって行動するオペレーターではなく、彼ら自身の合意に基づいて行動するオペレーターです。これが、オペレーターと前のトークン所有者の両方がトークン受信者にとって重要である理由です。

考慮される代替案：2ステップのERC-20スタイルのトランザクションのみを許可し、伝達関数がスローされないことを要求し、すべての関数が操作の成功を示すブール値を返すことを要求します。

##### ERC-165インターフェース

ERC-721スマートコントラクトがサポートするインターフェイスを公開するために、標準インターフェイス検出（ERC-165）を選択しました。

将来のEIPは、コントラクトのインターフェイスのグローバルレジストリを作成する可能性があります。このようなEIPを強力にサポートしており、ERC-721の実装ERC721EnumerableでERC721Metadataは、別のコントラクトに委任することで、、、またはその他のインターフェイスを実装できます。

##### ガスと複雑さ（列挙の拡張に関して）

この仕様は、少数の任意の数のNFTを管理する実装を想定しています。アプリケーションを拡張できる場合は、コードでfor / whileループを使用しないでください（CryptoKittiesバウンティの問題＃4を参照）。これらは、コントラクトを拡大できない可能性があり、ガスコストが時間の経過とともに際限なく上昇することを示しています。

コントラクトXXXXERC721をTestnetに展開し、340282366920938463463374607431768211456のさまざまな権利証（2 ^ 128）をインスタンス化して追跡します。これは、すべてのIPV6アドレスをEthereumアカウントの所有者に割り当てるか、ナノボットの所有権を数ミクロンのサイズで追跡し、合計で地球の半分のサイズにするのに十分です。ブロックチェーンからクエリできます。また、すべての関数は、ENSにクエリを実行するよりもガスを消費しません。

この図は、ERC-721標準スケールを明確に示しています。

検討する代替案：forループが必要な場合はアセット列挙関数を削除し、列挙関数からSolidity配列型を返します。

##### プライバシー

モチベーションセクションで特定されたウォレット/ブローカー/競売人は、所有者が所有しているNFTを特定する必要があります。

プロパティ所有権のプライベートレジストリや部分的にプライベートのレジストリなど、NFTを列挙できないユースケースを検討することは興味深いかもしれません。ownerOfただし、攻撃者は可能な限りすべてを（！）呼び出すことができるため、プライバシーを確​​保することはできませんtokenId。

##### メタデータの選択（メタデータ拡張）

メタデータ拡張機能に必要な機能がnameあります。symbolレビューしたすべてのトークンEIPとドラフト（ERC-20、ERC-223、ERC-677、ERC-777、ERC-827）には、これらの機能が含まれていました。

空の文字列は、このメカニズムの使用に抗議する場合の有効な応答であることを実装name者に通知します。symbolまた、スマートコントラクトは、コントラクトと同じ名前と記号を使用できることをすべての人に思い出させます。クライアントがどのERC-721スマートコントラクトがよく知られている（正規）かを判断する方法は、この標準の範囲外です。

NFTをURIに関連付けるメカニズムが提供されています。多くの実装がこれを利用して、各NFTのメタデータを提供することを期待しています。推奨される画像サイズはInstagramから取得したもので、おそらく画像の使いやすさについてよく知っています。URIは変更可能である可能性があります（つまり、時々変更されます）。家の所有権を表すNFTを検討しました。この場合、家に関するメタデータ（画像、居住者など）は自然に変化する可能性があります。

メタデータは文字列値として返されます。web3現在、これは他のコントラクトからではなく、からの呼び出しとしてのみ使用できます。オンブロックチェーンアプリケーションがそのような情報をクエリするユースケースを考慮していないため、これは許容できます。

検討する代替案：各アセットのすべてのメタデータをブロックチェーンに配置し（高すぎる）、URLテンプレートを使用してメタデータ部分をクエリします（URLテンプレートはすべてのURLスキーム、特にP2P URLで機能しない）、マルチアドレスネットワークアドレス（十分に成熟していない）

##### コミュニティの合意

元のERC-721の問題についてはかなりの議論があり、さらに、Gitterに関する最初のライブ会議が開催されました。これは、優れた表現と宣伝がありました（Reddit、Gitter #ERCチャネル、および元のERC-721の問題）。参加者に感謝します：


* @アラクニッドニックジョンソン
* @jadhavajayAyanWorksのAjayJadhav
* @superphly CodyMarxBailey -XRAMキャピタル/ハッカソンでの共有1月20日/国連の未来の金融ハッカソン。
* @fulldecent William Entriken

2番目のイベントがETHDenver2018で開催され、識別可能な資産基準について話し合いました（公開されるメモ）。

私たちはこのプロセスに非常に包括的であり、質問や貢献がある人は誰でも私たちの議論に招待します。ただし、この標準は、ここにリストされている特定されたユースケースをサポートするためにのみ作成されています。

#### 下位互換性

balanceOfERC-20仕様のtotalSupply、、、nameおよびsymbolセマンティクスを採用しています。実装には、この標準をサポートしながら、ERC-20との互換性を高めることが目標である場合decimalsに返される関数も含まれる場合があります。uint8(0)ただし、この機能をサポートするには、すべてのERC-721実装を要求するように工夫されていdecimalsます。

2018年2月現在のNFT実装の例：

* CryptoKitties –この標準の以前のバージョンと互換性があります。
* CryptoPunks –部分的にERC-20と互換性がありますが、コントラクトに直接オークション機能が含まれ、アセットを「パンク」として明示的に参照する関数名を使用するため、簡単に一般化することはできません。
* Auctionhouse Asset Interface –作成者は、AuctionhouseÐApp（現在はアイスボックス化されている）の汎用インターフェイスを必要としていました。彼の「資産」コントラクトは非常に単純ですが、ERC-20の互換性、approve()機能、およびメタデータが欠落しています。この取り組みは、EIP-173の説明で参照されています。

注：キュリオカードやレアペペなどの「限定版、収集可能なトークン」は、区別できる資産ではありません。1それらは実際には個々の代替可能なトークンのコレクションであり、それぞれが独自の総供給量（極端な場合）を持つ独自のスマートコントラクトによって追跡されます。

この関数は、関数を実装していなくても、特定の状況でonERC721Received誤って1（）を返す可能性のある古いデプロイ済みコントラクトを特に回避します（Solidity DelegateCallReturnValueバグを参照）。true魔法の値を返し、チェックすることで、実際の肯定的な反応とこれらの空虚な反応を区別することができtrueます。

#### テストケース

0xcert ERC-721トークンには、Truffleを使用して記述されたテストケースが含まれています。

#### 実装

0xcert ERC721 –リファレンス実装

* MITライセンスを取得しているため、プロジェクトで自由に使用できます
* テストケースを含む
* アクティブなバグバウンティ、エラーを見つけた場合は報酬が支払われます
Su Squares –スペースを借りて画像を配置できる広告プラットフォーム

* Su Squaresバグバウンティプログラムを完了して、この標準またはその実装に関する問題を探してください
* 完全な標準およびすべてのオプションのインターフェイスを実装します
* ERC721ExampleDeed –実装例

OpenZeppelinプロジェクト形式を使用して実装します
William EntrikenによるXXXXERC721–スケーラブルな実装例

* 10億のアセットを使用してテストネットにデプロイされ、メタデータ拡張機能を使用してすべてのルックアップをサポートします。これは、スケーリングが問題ではないことを示しています。
