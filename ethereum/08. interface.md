# 08. Solidity の interface

2025/02/06

Shigeichiro Yamasaki

* ERC-20 トークンの送金先コントラクトの作成
* IERC20 interface の利用

## Solidity の interface とは何か？

web3 アプリケーションのトークンは流通性を持たないと意味がありません．
そのために，ERC-20 や ERC-721 などの標準化されたトークンが重要になります．
標準化されたトークンはメタマスクなどの一般的なワレットで扱うことが可能だからです．
web3 アプリケーションは，これらの標準化されたトークンのコントラクトを継承することによって流通性をもたせることができます．

しかし，実際のトークンはアプリケーションによって様々な拡張機能を持ちます．そのような拡張機能を流通性を維持しながら有効利用する方法が必要になります．その方法が interface です．

ERC-20 の場合には，IERC-20 という openzeppelinによるインターフェースが存在します．ERC-721 には ERC-165 などのインターフェースが定義されています．また ERC-820 というレジストリ型のインターフェスの仕様も存在します．

### 既存の（古い）プログラムから新しいプログラムを利用する方法

既存のライブラリを利用して新しいプログラムを作成するのは簡単です．継承はそのような既存のライブラリを効率的に利用するしくみです．
しかし，既存の（古い）プログラムの側から新しいプログラムを呼び出して利用するのは簡単ではありません．

これを実現する技術は存在します．例えば，画像加工ソフトの photoshop では，画像処理プラグインモジュールでこれを実現しています．新しい画像処理モジュールを photoshop の特定のフォルダーにコピーすると，photoshopのメニューにその機能が追加されて使えるようになります．

PCに新しいプリンタを接続したときに，OSにデバイスドライバを組み込むと任意のアプリケーションの「プリント」メニューからそのプリンタで印刷できるようになるのも同様です．

こういった既存のプログラム（photoshopやOS）から新しいプログラム（プラグインモジュールやデバイスドライバ）が利用できるのは，既存のプログラムに画像加工やプリントのための標準インターフェースが定義されているからです．

### web3 アプリにおけるトークンへの interface の定義の重要性

* トークンの流通性
  
トークンはお金と同様にアプリケーションやサービスの境界を超えて広域的に流通します．
新しいトークンのために多数のアプリケーションやサービスがそれに対応してくれることを望むのは現実的ではありません．

* 既存アプリケーションからのトークンの新規機能の利用とweb3
  
既存のアプリケーションが，トークンの新しい機能の存在を知り，それを呼び出し，その結果を得るためのインターフェースが存在していることは，トークンの機能を中心にしたweb3 アプリケーションが，サーバー型の web2 アプリケーションと本質的に異なる点の一つです．


## Solidity の interface の条件

* 他のコントラクトから継承することはできませんが、他のインターフェースから継承することはできます。
* 宣言されたすべての関数は、コントラクト内で public であっても、interface 内では external である必要があります。
* コンストラクターを宣言することはできません。
* 状態変数を宣言することはできません。
* 修飾子を宣言することはできません。

## interface の例

### harfhat プロジェクト

```bash
cd ~/hardhat
mkdir interface
cd interface

yarn init -y
yarn add --dev hardhat
npx hardhat init

rm contracts/Lock.sol
rm test/Lock.js
rm ignition/modules/Lock.js
```

### Counter interface を試すコントラクト

```bash
nano contracts/counter.sol
```

```js
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract Counter {
    uint256 public count;

    function increment() external {
        count += 1;
    }
}

// Counter コントラクトへのインターフェース
interface ICounter {
    function count() external view returns (uint256);

    function increment() external;
}

// インターフェースを備えたコントラクト
contract MyContract {
    function incrementCounter(address _counter) external {
        ICounter(_counter).increment();
    }

    function getCount(address _counter) external view returns (uint256) {
        return ICounter(_counter).count();
    }
}

```

```bash
npx hardhat compile
```

* テスト

```bash
nano test/counter.js
```

```js
// hardhat tool box の利用
const {loadFixture} = require("@nomicfoundation/hardhat-toolbox/network-helpers");
// CHaiの利用
const { expect } = require("chai");

describe("counterコントラクトのインターフェース", function () {
     async function deployMyContractFixture() {
        const Counter = await ethers.deployContract("Counter",[]);
        const MyContract = await ethers.deployContract("MyContract",[]);
        return {Counter, MyContract};
     }
     it("MyContractでCounterを利用する", async function () {
      // コントラクトをロードする
      const {Counter, MyContract} = await loadFixture(deployMyContractFixture);
      // Counterコントラクトを利用して 2回カウントアップする
      await MyContract.incrementCounter(Counter.target);
      await MyContract.incrementCounter(Counter.target);
      // カウントを参照し，結果が 2n になる
      expect(await MyContract.getCount(Counter.target)).to.equal(2n);
    });
});

```



## ERC-165 (Standard Interface Detection) とは

スマートコントラクトにどのようなインターフェースが存在しているかを，公開・検知するための規格

* トークンが流通性を持つためには，相互運用性のためにそのトークンへのインターフェースが公開されている必要がある
* ERC-165 に準拠したコントラクトには以下の「インターフェースの存在を確認する関数」が定義されている．

```solidity
supportsInterface()
```

* ERC-5192 (SBT) は ERC-721 を基本にした NFT で， ERC-165 に準拠した最小限のインターフェースを定義可能にしたものです．
* SBT は，NFT の移転ができないように，移転のロックができる機能を備えています．
