# 09. アクセス制御

2025/02/09
Shigeichiro Yamasaki

 OpenZeppelin ライブラリを利用したアクセス制御について解説します．

* [https://docs.openzeppelin.com/](https://docs.openzeppelin.com/)
* [OpenZeppelin ライブラリのアクセス制御](https://docs.openzeppelin.com/contracts/2.x/access-control)

## Ownable コントラクトを継承

アクセス制御には，データ（情報資産）の管理のポリシーを組織が決定する MAC(Mandatory Access Control) とデータの所有者がポリシーを決定する DAC (Discretionary Access Control) がありますが，Web3 の世界の基本は DAC です．

したがって，すべてのデータへのアクセス制御は基本的に「その所有者」と結びついています．


### Ownable コントラクトを継承したコントラクト

* 以下は  Ownable コントラクトを多重継承した ERC20 コントラクトの例です

```js
// SPDX-License-Identifier: MIT
// Compatible with OpenZeppelin Contracts ^5.0.0
pragma solidity ^0.8.22;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

contract JPYcoin is ERC20, Ownable {
    constructor(address initialOwner)
        ERC20("JPYcoin", "JPQ")
        Ownable(initialOwner)
    {}
}

```

###  Ownable コントラクトを継承したコントラクトの機能

コントラクトは，Ownable という openzeppelin のコントラクトを継承すると以下の関数が利用可能になります

* owner() : コントラクトの現在の所有者のアカウント
* isOwner() : コントラクトへの呼び出し元が現在の所有者である場合は true を返します
* renounceOwnership() : コントラクトの所有権を放棄します
* transferOwnership(newOwner) : コントラクトの所有権を新しいアカウント(newOwner)に移譲します


### ロールベースアクセス制御

例えば「大学のサークルの部長」だけが実行可能な手続きがあったとします．
大学のサークルの部長が１年ごとに交代する場合，その手続の権限を持つ主体も交代しなければなりません．

このように，個人ではなく，サークルの部長のような「役割＝ロール」によって定義されるアクセス制御をロールベースアクセス制御(RBAC)といいます．

* Roles ライブラリ
  
Openzeppelin の Roles ライブラリを使ってロールベースアクセス制御を行うことが可能です．

[Roles](https://docs.openzeppelin.com/contracts/2.x/api/access#Roles)

以下のコードは，ERC-20 トークンに minters と burners という２つのロールを定義した例です．

```js
pragma solidity ^0.5.0;

// Rolesライブラリの利用
import "@openzeppelin/contracts/access/Roles.sol";
// ERC20 ライブラリ
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol";

contract MyToken is ERC20, ERC20Detailed {
    using Roles for Roles.Role;

    Roles.Role private _minters;
    Roles.Role private _burners;

    constructor(address[] memory minters, address[] memory burners)
        ERC20Detailed("MyToken", "MTKN", 18)
        public
    {
        for (uint256 i = 0; i < minters.length; ++i) {
            _minters.add(minters[i]);
        }

        for (uint256 i = 0; i < burners.length; ++i) {
            _burners.add(burners[i]);
        }
    }

    function mint(address to, uint256 amount) public {
        // Only minters can mint
        require(_minters.has(msg.sender), "DOES_NOT_HAVE_MINTER_ROLE");

        _mint(to, amount);
    }

    function burn(address from, uint256 amount) public {
        // Only burners can burn
        require(_burners.has(msg.sender), "DOES_NOT_HAVE_BURNER_ROLE");

       _burn(from, amount);
    }
}
```





## hardhat プロジェクトの作成

```bash
cd ~/hardhat
mkdir sbt
cd sbt
```

```bash
yarn init -y
yarn add --dev hardhat
npx hardhat init

// 消さなくても実害は無いが消しておく

rm contracts/Lock.sol
rm test/Lock.js
rm ignition/modules/Lock.js
```

## Solidity プログラム

SBT の solidity プログラム

```bash
nano contracts/sbt.sol
```

```js
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
contract HTLC {
    address payable public sender;
    address payable public receiver;
    bytes32 public hashlock;
    uint256 public timelock;
    uint256 public amount;
    event Log(address indexed _from, uint256 _value, string _msg);
// コンストラクタで受領者と送金者を確定し，ハッシュ値と時間で資金をデポジットする
    constructor(address payable _receiver,bytes32 _hashlock, uint256 _timelock) payable {
        sender = payable(msg.sender);
        receiver = _receiver;
        hashlock = _hashlock;
        timelock = _timelock;
    }
    // コントラクトがETHを受け取れるようにするための関数
    receive() external payable {
      emit Log(msg.sender, msg.value, "eth received");
    }
    // ハッシュ値の原像でアンロックし，デポジット資金を受領者に送金する
    function withdraw(bytes memory _preimage) public {
        require(msg.sender == receiver, "Only receiver can withdraw");
        amount = address(this).balance;
        require(amount > 0 , "Already withdrawn");
        require(sha256(_preimage) == hashlock, "Invalid preimage");
        receiver.transfer(amount);
    }
    // ロック時間経過後，senderが資金を回収する
    function refund() public  {
        require(msg.sender == sender, "Only sender can refund");
        amount = address(this).balance;
        require(amount > 0 , "Already withdrawn");
        require(block.timestamp >= timelock, "Timelock has not expired");
        sender.transfer(amount);
    }
}
```

###  コンパイル

```bash
npx hardhat compile
```

