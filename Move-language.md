# Move: A Language With Programmable Resources

Sam Blackshear, Evan Cheng, David L. Dill, Victor Gao, Ben Maurer, Todd Nowacki, Alistair Pott, Shaz Qadeer, Rain, Dario Russi, Stephane Sezer, Tim Zakian, Runtian Zhou*


## 概要

Libra Blockchain [1] [2]のための安全で柔軟なプログラミング言語であるMoveについて解説します。 
Moveは、カスタマイズ可能なトランザクションとスマートコントラクトの実装に使用される実行可能なバイトコード言語です。

 Moveの重要な特徴は、線形ロジック[3]に触発されたセマンティクスに基づいてカスタマイズできる「リソースタイプ」が定義できることです。

Move言語のリソースは複製や暗黙的な破棄ができなくなっており、プログラム上のストレージの位置(location)の間でのみ移動できます。

これらの安全性の保証は、Moveの型システムによって静的に実行されます。

こういった特別な保護を行っているにもかかわらず、リソースは通常のプログラム上の値(values)です。
つまり、データ構造に保存したり、プロシージャに引数として渡すことができます。

「ファーストクラス・リソース」は非常に一般的な概念であり、プログラマーは安全なデジタル資産を実装するだけでなく、資産をラッピングし、アクセス制御ポリシーを適用するための正しいビジネスロジックを作成するために使用できます。

Move言語のこの安全性と表現力により、トランザクション処理、検証管理など、Libraコインを含むLibraプロトコルの重要な部分をMoveによって実装できます。

## Introduction

インターネットとモバイルブロードバンドの到来により、世界中の何十億もの人々がつながり、知識へのアクセス、無料のコミュニケーション、および低コストでより便利な幅広いサービスが提供されています。
この接続性により、より多くの人々が金融エコシステムにアクセスできるようになりました。しかし、この進歩にもかかわらず、金融サービスへのアクセスは、それを最も必要とする人々にとって依然として制限されています。

Libraの使命は、この状況を変えることです[1]。この論文では、Libraプロトコルでカスタムトランザクションロジックとスマートコントラクトを実装するための新しいプログラミング言語であるMoveを紹介します[2]。 Moveを紹介するために：

1. ブロックチェーン上でデジタル資産を表現する際の課題を説明（セクション2）。
2. Moveの設計がこれらの課題にどのように対処しているかを説明（セクション3）。
3. Moveの主要な機能とプログラミングモデルの例指向の概要（セクション4）。
4. 言語および仮想マシンの設計の技術的な詳細（セクション5、セクション6、および付録A）。
5. 最後に、Moveでの進捗状況を要約し、言語進化の計画を説明し、LibraブロックチェーンでのサードパーティのMoveコードをサポートするためのロードマップを概説（セクション7）。


## 2. Managing Digital Assets on a Blockchain

まず、Moveのような「ブロックチェーンプログラミング言語」が果たす役割を読者が理解できるように、抽象レベルでブロックチェーンを簡単に説明します。

この説明では、言語の観点から関連する機能に焦点を当てるために、ブロックチェーンシステムの多くの重要な詳細を意図的に省略しています。

### An Abstract View of a Blockchain

ブロックチェーンは連鎖的に複製される状態マシンです[4] [5]。
システム内で状態マシンを複製していくノードは「バリデーター(validators)」と呼ばれます。

システムのユーザーは「トランザクション(transactions)」をバリデーターに送信します。

各バリデーターは、トランザクションを「実行(execute)」して内部の状態マシンを現在の状態から新しい状態に遷移する方法を知っています。

バリデーターは、トランザクション実行の共通の理解を活用して、レプリケートされた状態を集合的に定義および維持するためのコンセンサスプロトコルに従います。

以下の条件を満たすなら、バリデーターは次の状態がどのようなものであるかについて同意できます。

* •バリデーターは同じ状態から始まっている
* •バリデーターは次のトランザクションがどうあるべきかについて合意している
* •トランザクションの実行によって決定論的な状態遷移が生成される


このスキームを繰り返し適用すると、バリデーターは現在の状態に同意しながらトランザクションを処理できます。

コンセンサスプロトコルと状態遷移コンポーネントは、互いの実装の詳細に影響されないことに注意してください。

コンセンサスプロトコルがトランザクション間の完全な順序を保証し、状態遷移スキームが決定的である限り、コンポーネントは調和して相互作用できます。



### Encoding Digital Assets in an Open System


Moveのようなブロックチェーンプログラミング言語の役割は、遷移と状態の表現方法を決定することです。

豊かな金融インフラをサポートするために、Libra Blockchainの状態は、特定の時点でデジタル資産の所有者をエンコードできる必要があります。

さらに、状態遷移により、資産の譲渡が可能になります。

ブロックチェーンプログラミング言語の設計を知らせる必要がある他の考慮事項が1つあります。

他のパブリックブロックチェーンと同様に、Libraブロックチェーンはオープンシステムです。

誰でも現在のブロックチェーンの状態を表示したり、バリデーターにトランザクションを送信したりできます（つまり、状態遷移を提案します）。

従来、デジタル資産を管理するためのソフトウェア（銀行ソフトウェアなど）は、クローズドな特別な管理コントロールが行われていました。

パブリックブロックチェーンでは、すべての参加者が同じ立場にあります。
参加者は、好きな状態遷移を提案できますが、システムがすべての状態遷移を許可する必要はありません。

たとえば、Aliceは、Bobが所有する資産を転送する状態遷移を自由に提案できます。
状態遷移関数は、この状態遷移が無効であることを認識し、拒否できる必要があります。

オープンソフトウェアシステムのデジタル資産の所有権をエンコードする遷移と状態の表現を選択することは困難です。特に、デジタル資産でエンコードするのが難しい物理資産の2つのプロパティがあります。

* 希少性(Scarcity) 。システム内の資産の供給を制御する必要があります。既存の資産の複製は禁止する必要があり、新しい資産の作成は特権操作である必要があります。
* アクセス制御。システムの参加者は、アクセス制御ポリシーで資産を保護できる必要があります。

直観を構築するために、状態遷移の表現に関する一連の「strawman proposals （たたき台）」の中で、これらの問題がどのように発生するかを見ていきます。 *StrawCoin*と呼ばれる単一のデジタル資産を追跡するブロックチェーンを想定します。

ブロックチェーン状態Gは、ユーザーID（暗号化公開キーで表される）を各ユーザーが保持する*StrawCoin*をエンコードする自然数値にマップするキー値ストアとして構造化されます。
プロポーザルは、特定の評価ルールを使用して評価されるトランザクションスクリプトで構成され、グローバル状態に適用する更新を生成します。 

`G [𝐾]：= n` という表記は、グローバルブロックチェーン状態のキーkeyに格納されている自然数を値 n で更新することを意味します。

各提案の目標は、AliceがStrawCoinをBobに送信するのに十分な表現力を持ちながら、ユーザーが希少性やアクセス制御プロパティに違反することを防ぐのに十分な制約があるシステムを設計することです。
この提案は、重要ではあるが希少性とアクセス制御に関する議論とは無関係のリプレイ攻撃[6]などのセキュリティ問題に対処しようとはしていません。

希少性(Scarcity)。最も簡単なやり方は、トランザクションスクリプト内の状態への更新を直接エンコードすることです。

![](./move/move001.png)


この表現によって、AliceからBobへのStrawCoinの送信をエンコードできます。
しかし、いくつかの深刻な問題があります。
一つには、この提案はStrawCoinの不足を強制しません。
アリスは、`⟨Alice, 100⟩` というトランザクションを送信することで、「真空から」好きなだけの量の *StrawCoin* を提供できてしまいます。

したがって、AliceがBobに送信するStrawCoinは、Bobが自分でそれらのコインを簡単に作成できたため、事実上価値がありません。

希少性は貴重な物理的資産の重要な特性です。
金のような希少金属は自然に不足していますが、デジタル資産に固有の物理的不足はありません。

 `G[Alice] → 10` というバイトシーケンスとしてエンコードされたデジタル資産は、`G [Alice]→100` などの他のバイトシーケンスよりも物理的に作成やコピーが難しいというわけではありません。
 
 代わりに、評価ルールは不足をプログラムで強制する必要があります。
 
希少性を考慮した2番目の提案を考えてみましょう。


![](./move/move002.png)

このスキームでは、トランザクションスクリプトは送信者の公開鍵 $K_a$ と受信者の公開鍵 $K_b$ の両方を指定します。

評価ルールは、更新を実行する前に $K_a$ に保存されているStrawCoinの数が少なくとも n であることを確認するようになりました。

チェックが成功すると、評価ルールは送信者のキーの下に保存されているStrawCoinから𝑛を引き、受信者のキーの下に保存されているStrawCoinに𝑛を追加します。

このスキームでは、有効なトランザクションスクリプトを実行すると、システム内のStrawCoinの数が節約されるため、希少性が実現されます。

アリスはもはや空からStrawCoinを作成することはできません。彼女はアカウントから引き落とされたボブStrawCoinのみを与えることができます。


#### アクセス制御。 

2番目の提案は希少性の問題に対処していますが、それでも問題があります。

ボブはアリスに属するStrawCoinを使用するトランザクションを送信できます。

たとえば、評価ルールには、ボブがトランザクション `⟨Alice, 100, Bob⟩` を送信するのを止めるものは何もありません。
デジタル署名に基づくアクセス制御メカニズムを追加することにより、これに対処できます


![](./move/move003.png)


このスキームでは、アリスがプライベートキーでトランザクションスクリプトに署名する必要があります。

公開鍵pairとペアになった秘密鍵を使用して、メッセージsignに署名することを `𝑆𝐾(m)`と表記します。評価ルールは、verify_sig関数を使用して、Aliceの公開キーに対する署名を確認します𝐾𝑎。署名が検証されない場合、更新は実行されません。

この新しいルールは、デジタル署名の偽造不可能性を使用して、アリスが自分以外のアカウントからStrawCoinを引き落とさないようにすることで、以前の提案の問題を解決します。

余談ですが、最初の「たたきだい (strawman proposal)」では評価ルールが事実上必要ないことに注意してください。

提案された状態の更新は、キーと値のストアに直接適用されました。しかし、提案を進めていくと、更新を実行するための前提条件と更新自体の間の明確な分離が明らかになりました。評価ルールは、スクリプトを評価することにより、更新を実行するかどうかと実行する更新の両方を決定します。

アクセス制御と希少性ポリシーを実施するためには何らかの評価が必要になるため、この分離は基本です。

ユーザーは状態変更を提案し、状態変更がポリシーに準拠しているかどうかを判断するために計算を実行する必要があります。

オープンシステムでは、参加者は、ポリシーをオフチェーンで実施し、状態に対して直接更新を送信することはできません（最初の提案のように）。

代わりに、アクセス制御ポリシーは評価ルールによってチェーン上で実施する必要があります。


### Existing Blockchain Languages


StrawCoinはおもちゃの言語ですが、Bitcoin Script [7] [8]およびEthereum Virtual Machineバイトコード[9]言語（特に後者）の本質を表しています。

これらの言語はStrawCoinよりも高度ですが、同じ問題の多くに直面しています。

1. 資産の間接的な表現。資産は整数を使用してエンコードされますが、整数値は資産と同じではありません。実際、Bitcoin / Ether / StrawCoinを表す型や値はありません！これにより、アセットを使用するプログラムを作成するのが難しくなり、エラーが発生しやすくなります。プロシージャへのアセットの受け渡しやデータ構造へのアセットの保存などのパターンには、特別な言語サポートが必要です。

2. 希少性は拡張できません。この言語は、1つの希少な資産のみを表します。さらに、不足の保護は、言語のセマンティクスに直接ハードコーディングされています。カスタマイズされた資産を作成したいプログラマーは、言語処理系のサポートなしで、足りない部分を慎重に再実装する必要があります。
 
3. アクセス制御は柔軟ではありません。モデルが実施する唯一のアクセス制御ポリシーは、公開鍵に基づく署名スキームです。希少性保護と同様に、アクセス制御ポリシーは言語セマンティクスに深く組み込まれています。プログラマーがカスタムアクセス制御ポリシーを定義できるように言語を拡張する方法は明らかではありません。

#### Bitcoin Script.

 Bitcoin Scriptのシンプルでエレガントなデザインは、Bitcoinを使用するためのカスタムアクセス制御ポリシーの表現に焦点を当てています。グローバル状態は、未使用のトランザクション出力（UTXO）のセットで構成されます。
 
 ビットコインスクリプトプログラムは、消費する古いUTXOのアクセス制御ポリシーを満たす入力（デジタル署名など）を提供し、作成する新しいUTXOのカスタムアクセス制御ポリシーを指定します。
 
Bitcoin Scriptにはデジタル署名チェック用の強力な命令（多重署名[10]サポートを含む）が含まれているため、プログラマーはさまざまなアクセス制御ポリシーをエンコードできます。
 
ただし、ビットコインスクリプトの表現力は根本的に制限されています。プログラマはカスタムデータ型（およびその結果としてカスタムアセット）またはプロシージャを定義できず、言語はチューリング完全ではありません。

協力関係者は、複雑なマルチトランザクションプロトコル[11]でより高度な計算を実行したり、「カラードコイン」[12] [13]でカスタムアセットを非公式に定義したりすることができます。

ただし、これらのスキームは言語の外に複雑さを押し出すことで機能しているため、真の拡張性を実現できているわけではありません。

#### Ethereum Virtual Machine bytecode. 


イーサリアムは、単なる支払い以上のブロックチェーンシステムの使用方法を示す画期的なシステムです。

 Ethereum Virtual Machine（EVM）バイトコードプログラマは、Etherなどの資産とやり取りし、チューリング完全言語を使用して新しい資産を定義するスマートコントラクト[14]を公開できます。 
 
 EVMは、ユーザー定義の手順、仮想呼び出し、ループ、データ構造など、ビットコインスクリプトではサポートされていない多くの機能をサポートしています。

ただし、EVMの表現力は、高価なプログラミングの間違いへの扉を開いています。 

StrawCoinと同様に、Ether通貨は言語で特別なステータスを持ち、希少性を強制する方法で実装されます。

ただし、カスタムアセットの実装者（たとえば、ERC20 [15]標準経由）は、これらの保護を継承しません（（2）で説明）。

アセットの複製、再利用、または損失を許可するバグを導入しないように注意する必要があります。

これは、（1）で説明されている間接表現の問題とEVMの非常に動的な動作の組み合わせにより困難です。特に、Etherをスマートコントラクトに転送するには、動的なディスパッチが必要です。

これにより、再入可能性の脆弱性として知られる新しいクラスのバグが発生しました[16]。 
DAO攻撃[17]やパリティウォレットハック[18]などの有名なエクスプロイトにより、攻撃者は数百万ドル相当の暗号通貨を盗むことができました

## 3. Move Design Goals


Libraの使命は、数十億人を支援するシンプルなグローバル通貨と金融インフラを実現することです[1]。

 Move言語は、このビジョンを構築できる安全でプログラム可能な基盤を提供するように設計されています。 Moveは、Libra通貨とガバナンスルールを、正確で、理解可能で、検証可能な方法で表現できなければなりません。
 
 長期的には、Moveは、金融インフラストラクチャを構成する豊富な種類の資産と対応するビジネスロジックをエンコードできる必要があります。

これらの要件を満たすために、一流の資産、柔軟性、安全性、検証可能性という4つの重要な目標を念頭に置いてMoveを設計しました。

### First-Class Resources


ブロックチェーンシステムにより、ユーザーはデジタル資産と直接やり取りするプログラムを作成できます。

セクション2.2で説明したように、デジタル資産には、ブール値、整数、文字列など、プログラミングで伝統的に使用される値とは異なる特別な特性があります。
デジタル資産を使用するプログラミングが堅牢なものになるには、これらの特性を保持できるようにすることが必要です。

Moveの主要な機能は、線形ロジック[3]に触発されたセマンティクスでカスタムリソースタイプを定義する機能です。

リソースは複製や暗黙的な破棄ができず、プログラム上のストレージの位置の間でのみ移動できます。これらの安全保証は、Moveの型システムによって静的に実施されます。これらの特別な保護にもかかわらず、リソースは通常のプログラム上の値です。

データ構造に保存したり、プロシージャに引数として渡すことができます。

「ファーストクラス・リソース」は非常に一般的な概念であり、プログラマーは安全なデジタル資産を実装するだけでなく、資産をラッピングし、アクセス制御ポリシーを適用するための正しいビジネスロジックを作成するために使用できます。

Libraコイン自体も、言語処理系の中で特別なものではなく通常のMoveリソースとして実装されます。 

LibraコインはLibraリザーブ[19]によって管理される実世界の資産を表すため、Moveはリソースの作成（たとえば、新しい実世界の資産がLibraリザーブに入ったとき）、修正（たとえば、デジタル資産の所有権の変更）、および破棄されます（たとえば、デジタル資産を支える物理資産が売却されたとき）。

Moveプログラマは、「モジュール(modules)」によってこれらの重要な操作へのアクセスを保護できます。

Moveモジュールは、他のブロックチェーン言語のスマートコントラクトに似ています。

モジュールは、宣言されたリソースを作成、破棄、および更新するためのルールをエンコードするリソースタイプとプロシージャを宣言します。

モジュールは、他のモジュールによって宣言されたプロシージャを呼び出し、他のモジュールによって宣言された型を使用できます。

ただし、モジュールは強力なデータ抽象化を強制します。

型は宣言モジュール内では透明で、外部では不透明です。さらに、リソースタイプTの重要な操作は、Tを定義するモジュール内でのみ実行できます。


### Flexibility

Moveは、トランザクションスクリプトを介してLibraに柔軟性を追加します。
各Libraトランザクションには、トランザクションのメインプロシージャであるトランザクションスクリプトが含まれています。

トランザクションスクリプトは、カスタマイズ可能なトランザクションを可能にする任意のMoveコードを含む単一のプロシージャです。

スクリプトは、ブロックチェーンで公開されたモジュールの複数のプロシージャを呼び出し、結果に対してローカル計算を実行できます。

つまり、スクリプトは、表現力豊かな単発的な動作（特定の受信者への支払いなど）または再利用可能な動作（再利用可能なロジックをカプセル化する単一のプロシージャを呼び出す）のいずれかを実行できます。

Moveモジュールは、安全でありながら柔軟なコード構成により、異なる種類の柔軟性を実現します。

高レベルでは、Moveのモジュール/リソース/プロシージャ間の関係は、オブジェクト指向プログラミングのクラス/オブジェクト/メソッド間の関係に似ています。

ただし、重要な違いがあります。Moveモジュールは複数のリソースタイプ（またはゼロのリソースタイプ）を宣言でき、Moveプロシージャは *self* や *this* の概念を持ちません。

Moveのモジュールは、ML-スタイルのモジュールを制限したものに似ています[20]。


### Safety

Moveは、リソースの安全性、タイプの安全性、メモリの安全性など、主要なプロパティを満たさないプログラムを拒否する必要があります。

ブロックチェーンで実行されるすべてのプログラムがこれらの特性を満たすことを保証する実行可能な表現をどのように選択できますか？ 

* （a）これらのプロパティをチェックするコンパイラで高レベルのプログラミング言語を使用するか、
* （b）実行時に低レベルの型なしアセンブリを使用してこれらの安全性チェックを実行します。

Moveは、これら2つの極端なアプローチを取ります。 
Moveの実行可能形式は、アセンブリよりも高レベルでありながらソース言語よりも低レベルの型付きバイトコードです。

バイトコードは、バイトコード検証ツール3によってチェーン上でリソース、タイプ、およびメモリの安全性がチェックされ、バイトコードインタープリターによって直接実行されます。

この選択により、Moveは、ソースコンパイラを信頼できるコンピューティングベースに追加したり、コンパイルのコストをトランザクション実行のクリティカルパスに追加したりすることなく、通常ソース言語に関連付けられた安全性を保証できます。


### Verifiability

理想としては、オンチェーンのバイトコードの分析やランタイムチェックを介してMoveプログラムのすべての安全性プロパティをチェックすべきです。

しかし残念ながら、これは現実的ではありません。安全性保証の重要性と一般性、計算コスト、オンチェーン検証で保証を強化するプロトコルの複雑さについて慎重に比較検討する必要があります。

私たちのアプローチは、主要な安全性プロパティとしては可能な限り軽量のオンチェーン検証にとどめておきながら、高度なオフチェーンの静的検証ツールをサポートするようにMove言語を設計しました。 

我々は、Move言語を既存の汎用言語よりも静的検証を受け入れやすくするために、以下のような設計方針をとりました。

1. 動的ディスパッチの禁止。
各コールサイトの対象は静的に決定されます。
これにより、検証ツールは、複雑なコールグラフ構造分析を実行することなく、プロシージャコールの影響を正確に推論できます。


2. ミュータビリティの制限。 Moveでは、値に対する更新は、すべて参照を介して行われます。
参照は、単一のトランザクションスクリプトの範囲内で作成され破棄される必要がある一時的な値です。
Moveのバイトコード検証では、Rustに似た「借用チェック(borrow checking)」スキームを使用して、任意の時点で値へのミュータブルな参照が最大1つしか存在しないことを検証します。
さらに、この言語は、グローバルストレージが常に任意のグラフ構造ではなくツリー構造であることを保証します。
これにより、検証ツールは書き込み操作の影響に関する推論をモジュール化できます。


3. モジュラリティ。Moveモジュールは、データの抽象化を強制し、リソースに対するクリティカルな操作を局所化します。
モジュールによるカプセル化と、Moveタイプシステムによって強制されるリソース保護を組み合わせることにより、モジュールのタイプが付与されて格納されている資産がモジュール外のコードによって侵害されないことが保証されます。
この設計により、クライアントを考慮することなく、個々のモジュールを独立に検証することにより、重要なモジュール不変性の完全な機能検証が可能になることが期待されます。


静的検証ツールは、Moveのこれらの特徴を活用して、ランタイムエラー（整数オーバーフローなど）がないことと、プログラム固有の重要な機能的な正当性（e.g. ペイメントチャンネルでロックされているリソースを最終的に当事者が要求できることなど）の両方を正確かつ効率的にチェックできます。
セクション7で機能的正統性の検証の計画の詳細を説明します。

## 4. Move Overview

Moveの基本を紹介するために、単純なピアツーピアの支払いに関係するトランザクションスクリプトとモジュールについて説明します。

このモジュールは、実際のLibraコイン実装の簡易バージョンです。サンプルのトランザクションスクリプトは、モジュール外の悪意のあるまたは不注意なプログラマーが、モジュールのリソースの主要な安全性の不変条件に違反できないことを示しています。

サンプルモジュールは、強力なデータ抽象化を活用してこれらの不変条件を確立および維持するリソースを実装する方法を示しています。

このセクションのコードスニペットは、Move中間表現（IR）のバリアントで記述されています。

 Move IRは、人間が読めるコードを記述するのに十分な高レベルですが、Moveバイトコードに直接変換できるほど低レベルです。スタックベースのMoveバイトコードは読みにくいため、IRでコードを提示します。
 
現在、Moveソース言語を設計しています（セクション7を参照）。 
 
 Moveタイプシステムによって、コードを実行する前にバイトコードレベルで提供されるすべての安全性保証がチェックされていることに注意してください。


### 4.1. Peer-to-Peer Payment Transaction Script



```java
public main(payee: address, amount: u64) {
  let coin: 0x0.Currency.Coin = 0x0.Currency.withdraw_from_sender(copy(amount));
  0x0.Currency.deposit(copy(payee), move(coin));
}
```

このスクリプトは、支払いの受取人のアカウントアドレスと受取人に送金されるコインの数を表す符号なし整数の2つの入力を取ります。このスクリプトを実行する効果は簡単です。金額のコインがトランザクション送信者から受取人に転送されます。

これは2つのステップで発生します。

最初のステップで、送信者は、`0x0.Currency` に保存されているモジュールから `withdraw_from_sender` という名前のプロシージャを呼び出します。

セクション4.2で説明するように、0x0はモジュールが保存されているアカウントアドレスであり、通貨はモジュールの名前です。

このプロシージャによって返される値コインは、タイプが `0x0.Currency.Coin` のリソース値です。 2番目のステップでは、送信者はコインリソースの値を `0x0.Currency` モジュールの入金手順に移動することにより、受取人に資金を転送します。

この例は非常にデリケートなので興味深いものです。
 Moveのタイプシステムは、同じコードの小さなバリアントを拒否し、不適切な動作を引き起こします。
 
 特に、型システムは、リソースの複製、再利用、または損失を防ぐことができます。たとえば、スクリプトに対する次の3つの変更は、型システムによって拒否されます。


#### Duplicating currency by changing move(coin) to copy(coin)

この例で、それぞれの変数が、`copy()` や `move()`でラップされていることに注意してください。 

Move言語は、RustやC ++と同様、「ムーブセマンティクス」を実装しています。 

Moveでは変数xを読み取るたびに、その使用法がxの値を変数から移動するためのものか（レンダリングxが使用不可）、値をコピーするためのものか（xを引き続き使用できるようにする）を指定する必要があります。 

u64やaddressなどの無制限の値は、コピーと移動の両方が可能です。ただし、リソース値は移動のみ可能です。リソース値を複製しようとすると（上記の例でcopy（coin）を使用するなど）、バイトコード検証時にエラーが発生します。

#### Reusing currency by writing Move(coin) twice.

行 `0x0.Currency.deposit(copy(some_other_payee), move(coin)) ` を上記の例に追加すると、送信者はコインを2回「支出」できます。1回目は受取人、2回目はsome_other_payeeです。
この望ましくない動作は、物理的な資産では不可能です。さいわい、Moveはこのプログラムを拒否します。変動コインは最初の移動後に利用できなくなり、2番目の移動はバイトコード検証エラーをトリガーします


#### Losing currency by neglecting to Move(coin). 

Move言語は、*1回だけ* 移動する必要がある線形[3] [23]リソースを実装します。
リソースの移動に失敗すると（たとえば、上記の例の Move（coin）を含む行を削除することにより）、バイトコード検証エラーがトリガーされます。

これにより、Moveプログラマーが誤って（または意図的に）リソースを追跡できなくなるのを防ぎます。これらの保証は、紙幣などの物理的資産で可能なことを超えています。

リソースの安全性という用語を使用して、Moveリソースがコピー、再利用、または失われないことを保証します。 
Moveプログラマーはこれらの保護を享受するカスタムリソースを実装できるため、これらの保証は非常に強力です。
セクション3.1で説明したように、Libra通貨でさえ、Move言語で特別なステータスのないカスタムリソースとして実装されます。

### Currency Module

このセクションでは、上記の例で使用されているCurrencyモジュールの実装がリソースの安全性を活用して、安全な代替資産を実装する方法を示します。まず、Moveコードが実行されるブロックチェーン環境について少し説明します。

#### Primer：Move実行モデル

セクション3.2で説明したように、Moveには2種類のプログラムがあります。

セクション4.1で説明した例のようなトランザクションスクリプトと、後ほど説明する通貨モジュールなどのモジュールです。

例のようなトランザクションスクリプトは、ユーザーが送信した各トランザクションに含まれ、モジュールのプロシージャを呼び出してグローバル状態を更新します。

トランザクションスクリプトの実行は、すべてかゼロかです。
実行が正常に完了し、スクリプトによって実行されたすべての書き込みがグローバルストレージにコミットされるか、実行がエラーで終了します（たとえば、アサーションの失敗またはアウトオブガスエラー）、および何もコミットされていません。トランザクションスクリプトは使い捨てのコードです。
実行後は、他のトランザクションスクリプトまたはモジュールから再度呼び出すことはできません。

対照的に、モジュールはグローバルな状態で公開された長命のコードです。上記の例で使用されているモジュール名`0x0.Currency` には、モジュールコードが公開されているアカウントアドレス0x0が含まれています。グローバル状態は、アカウントアドレスからアカウントへのマップとして構造化されます。

![](./move/move004.png)



各アカウントには、0個以上のモジュール（四角形で表示）と1つ以上のリソース値（シリンダーで表示）を含めることができます。たとえば、アドレス0x0のアカウントには、モジュール `0x0.Currency` とタイプ `0x0.Currency.Coin` のリソース値が含まれています。アドレス0x1のアカウントには、2つのリソースと1つのモジュールがあります。アドレス0x2のアカウントには2つのモジュールと1つのリソース値があります。


アカウントには、指定されたタイプの最大1つのリソース値と、指定された名前の最大1つのモジュールを含めることができます。

アドレス0x0のアカウントには、追加の `0x0.Currency.Coin` リソースまたは`Currency` という名前の別のモジュールを含めることはできません。

ただし、アドレス0x1のアカウントは、Currencyというモジュールを追加できます。その場合、0x0はタイプ0x1.Currency.Coinのリソースも保持できます。 `0x0.Currency.Coinと0x1.Currency.Coin` は、互換的に使用できない別個のタイプです。宣言モジュールのアドレスは型の一部です。

アカウントで指定されたタイプのリソースを1つしか許可しないことに注意してください。この設計は、最上位のアカウント値に予測可能なストレージスキーマを提供します。プログラマーは、カスタムラッパーリソースを定義することにより、アカウント内の特定のリソースタイプの複数のインスタンスを保持できます。

```java
resource TwoCoins { c1: 0x0.Currency.Coin, c2: 0x0.Currency.Coin }
```

#### Declaring the Coin resource. 

モジュールがMove実行モデルにどのように適合するかを説明したので、ついにCurrencyモジュールの内部を見る準備ができました。

```java
module Currency {
  resource Coin { value: u64 }
  // ...
}
```


このコードは、`Currency` というモジュールと、モジュールによって管理される `Coin` というリソースタイプを宣言します。 

`Coin` は、u64型（64ビット符号なし整数）の単一フィールド値を持つ構造体型です。

 Coinの構造は、Currencyモジュールの外部では不透明です。他のモジュールおよびトランザクションスクリプトは、モジュールによって公開されるパブリックプロシージャを介してのみ値フィールドの書き込みまたは参照を行うことができます。同様に、通貨モジュールのプロシージャのみが、コイン型の値を作成または破棄できます。

このスキームにより、強力なデータ抽象化が可能になります。モジュール作成者は、宣言されたリソースのアクセス、作成、および破棄を完全に制御できます。 

Currencyモジュールによって公開されたAPIの外で、別のモジュールがCoinで実行できる操作は移動のみです。リソースの安全性により、他のモジュールがリソースをコピー、破壊、または二重に移動することを禁止しています。


#### Implementing deposit. 


前のセクションでトランザクションスクリプトによって呼び出されたCurrency.depositプロシージャがどのように機能するかを調べてみましょう。

```java
public deposit(payee: address, to_deposit: Coin) {
  let to_deposit_value: u64 = Unpack<Coin>(Move(to_deposit));
  let coin_ref: &mut Coin = BorrowGlobal<Coin>(Move(payee));
  let coin_value_ref: &mut u64 = &mut Move(coin_ref).value;
  let coin_value: u64 = *Move(coin_value_ref);
  *Move(coin_value_ref) = Move(coin_value) + Move(to_deposit_value);
}
```

高レベルでは、このプロシージャはCoinリソースを入力として受け取り、それを支払い先のアカウントに保存されているCoinリソースと結合します。これは次の方法で実現します。

1. 入力コインを破棄し、その値を記録します。
2. 受取人のアカウントの下に保存されている一意のCoinリソースへの参照を取得します。
3. 受取人のコインの価値を、手続きに渡されたコインの価値で増やします。

この手順の低レベルのメカニズムには、説明する価値のある側面がいくつかあります。 

`to_deposit` にバインドされた `Coin`リソースは、`deposit` プロシージャが所有しています。
プロシージャを呼び出すには、呼び出し元は `to_deposit` にバインドされた `Coin` を呼び出し先に移動する必要があります（これにより、呼び出し元が再利用できなくなります）。


最初の行で呼び出される `Unpack` プロシージャは、モジュールによって宣言された型を操作するためのいくつかのモジュール組み込み関数の1つです。 

`Unpack <T>` は、タイプTのリソースを削除する唯一の方法です。タイプTのリソースを入力として受け取り、それを破棄し、リソースのフィールドにバインドされた値を返します。 

`Unpack` などのモジュールビルトインは、現在のモジュールで宣言されているリソースでのみ使用できます。 `Unpack` の場合、この制約は他のコードがCoinを破壊することを防ぎます。これにより、`Currency` モジュールは `Coin` リソースの破壊にカスタム前提条件を設定できます（たとえば、ゼロの破壊のみを許可することを選択できます）価値のあるコイン）



3行目で呼び出される `BorrowGlobal` プロシージャもモジュールに組み込まれています。 `BorrowGlobal <T>` はアドレスを入力として受け取り、そのアドレスで発行されたTの一意のインスタンスへの参照を返します6。

これは、上記のコードのcoin_refのタイプが `＆mut Coin`（所有するCoinリソースであるCoinではなくCoinリソースへの可変参照）であることを意味します。

次の行は、`Coin_ref` にバインドされた参照値を移動して、Coinの値フィールドへの参照 `coin_value_ref` を取得します。手順の最後の行では、支払い先の `Coin`リソースの以前の値を読み取り、`coin_value_ref` を変更して、預け入れ金額を反映させます7。

Move型システムは、モジュール内のすべての実装ミスをキャッチできないことに注意してください。たとえば、型システムは、存在するすべてのコインの合計値が預金の呼び出しによって保持されることを保証しません。

プログラマが `Move（coin_value_ref）= 1 + Move（coin_value）+ Move（to_deposit_value）` を最終行に間違えた場合、型システムは問題なくコードを受け入れます。

これは、責任の明確な分割を示唆しています。モジュールの境界内でコインの適切な安全不変量を確立するのはプログラマーの仕事であり、モジュール外のコインのクライアントがこれらの不変量に​​違反できないことを保証するのは型システムの仕事です。


#### Implementing withdraw_from_sender.


上記の実装では、入金手順による資金の入金には承認は必要ありません。入金は誰でも呼び出すことができます。
対照的に、アカウントからの引き出しは、通貨リソースの所有者に排他的な特権を付与するアクセス制御ポリシーによって保護する必要があります。
ピアツーピアの支払いトランザクションスクリプトによって呼び出されるwithdraw_from_senderプロシージャがどのようにこの承認を実装するかを見てみましょう。

```java
public withdraw_from_sender(amount: u64): Coin {
  let transaction_sender_address: address = GetTxnSenderAddress();
  let coin_ref: &mut Coin = BorrowGlobal<Coin>(Move(transaction_sender_address));
  let coin_value_ref: &mut u64 = &mut Move(coin_ref).value;
  let coin_value: u64 = *Move(coin_value_ref);
  RejectUnless(copy(coin_value) >= copy(amount));
  *Move(coin_value_ref) = Move(coin_value) - copy(amount);
  let new_coin: Coin = Pack<Coin>(Move(amount));
  return Move(new_coin);
}
```

この手順は、預金のほとんど逆ですが、完全ではありません。それ：

1. 送信者のアカウントで公開されたタイプCoinの一意のリソースへの参照を取得します。
2. 参照されるコインの値を入力量だけ減らします。
3. 価値のある新しいコインを作成して返します。


この手順で実行されるアクセス制御チェックはやや微妙です。預金手続きにより、呼び出し側はBorrowGlobalに渡されるアドレスを指定できますが、withdraw_from_senderはGetTxnSenderAddressによって返されたアドレスのみを渡すことができます。このプロシージャは、Moveコードが現在実行中のトランザクションからデータを読み取ることができるいくつかのトランザクション組み込み関数の1つです。

移動仮想マシンは、トランザクションが実行される前に送信者アドレスを認証します。この方法でBorrowGlobalビルトインを使用すると、トランザクションの送信者は自分のCoinリソースからのみ資金を引き出すことができます。

すべてのモジュール組み込み関数と同様に、`BorrowGlobal <Coin>` は、Coinを宣言するモジュール内でのみ呼び出すことができます。 

CurrencyモジュールがBorrowGlobalの結果を返すプロシージャを公開しない場合、Currencyモジュール外のコードがグローバルストレージで公開されたCoinリソースへの参照を取得する方法はありません。


トランザクション送信者のCoinリソースの値を減らす前に、RejectUnless命令を使用して、コインの値が入力された正式な金額以上であることを確認します。これにより、送信者は自分が持っているよりも多く引き出すことができなくなります。このチェックが失敗すると、現在のトランザクションスクリプトの実行が停止し、実行した操作はいずれもグローバルステートに適用されません。

最後に、この手順では、送信者のCoinの値を量だけ減らし、Unpackの逆を使用して新しいCoinリソースを作成します—組み込みのPackモジュールPack <T>はタイプTの新しいリソースを作成します。Unpack<T>と同様に、Pack <T>はリソースTの宣言モジュール内でのみ呼び出すことができます。

ここで、PackはタイプCoinのリソースnew_coinを作成し、移動します発信者に。発信者はこのCoinリソースを所有し、好きな場所に移動できます。セクション4.1のサンプルトランザクションスクリプトでは、発信者はコインを支払い先のアカウントに入金することを選択します。


## 5. The Move Language

このセクションでは、Move言語、バイトコード検証、および仮想マシンの準形式的な説明を示します。付録Aでは、これらのコンポーネントをすべて詳細に説明していますが、散文は含まれていません。ここでの議論では、付録からの抜粋を使用し、時々そこに定義されているシンボルを参照します。

![](./move/move005.png)


Moveの目標は、プログラマーがグローバルブロックチェーン状態を定義し、グローバル状態を更新する操作を安全に実装できるようにすることです。セクション4.2で説明したように、グローバル状態はアドレスからアカウントへの部分的なマップとして編成されます。

アカウントには、リソースデータ値とモジュールコード値の両方が含まれます。アカウント内の異なるリソースには、個別の識別子が必要です。アカウント内の異なるモジュールには異なる名前が必要です。


![](./move/move006.png)

モジュールは、名前、構造体宣言（これから説明するリソースを含む）、およびプロシージャ宣言で構成されます。

コードは、モジュールのアカウントアドレスとモジュール名で構成される一意の識別子を使用して、公開されたモジュールを参照できます。
モジュール識別子は、モジュール外のコードの構造体型とプロシージャの識別子を修飾する名前空間として機能します。

Moveモジュールは、強力なデータ抽象化を可能にします。モジュールのプロシージャは、モジュールによって宣言された型を作成、書き込み、および破棄するためのルールをエンコードします。型は、宣言モジュールの内部では透明で、外部では不透明です。

 Moveモジュールは、MoveToSender命令を使用してアカウントでリソースを公開し、BorrowGlobal命令を使用してアカウントでリソースへの参照を取得し、MoveFrom命令を使用してアカウントからリソースを削除するための前提条件を強制することもできます。

モジュールにより、Moveプログラマーは、リソースに対する豊富なアクセス制御ポリシーを柔軟に定義できます。たとえば、モジュールは、fフィールドがゼロの場合にのみ破棄できるリソースタイプ、または特定のアカウントアドレスでのみ公開できるリソースを定義できます。

![](./move/move007.png)

Moveは、ブール値、64ビット符号なし整数、256ビットアカウントアドレス、固定サイズのバイト配列などのプリミティブ型をサポートしています。構造体は、モジュールによって宣言されたユーザー定義型です。構造体タイプは、リソースの種類でタグ付けすることにより、リソースとして指定されます。
非リソース構造体型およびプリミティブ型を含む他のすべての型は、無制限型と呼ばれます。

リソースタイプの変数はリソース変数です。
無制限タイプの変数は無制限変数です。バイトコード検証は、リソース変数とリソースタイプの構造体フィールドに制限を適用します。リソース変数はコピーできず、常に移動する必要があります。

リソース変数とリソースタイプの構造体フィールドの両方を再割り当てすることはできません。再割り当てすると、以前に保管場所に保持されていたリソース値が破壊されます。さらに、リソースタイプへの参照は逆参照できません。これは、基になるリソースのコピーを作成するためです。対照的に、無制限の型はコピー、再割り当て、および間接参照できます。

最後に、無制限の構造体型には、リソース型のフィールドを含めることはできません。
この制限により、（a）無制限の構造体をコピーしてもネストされたリソースがコピーされなくなり、（b）無制限の構造体を再割り当てしてもネストされたリソースが破壊されなくなります。

参照型は、可変または不変のいずれかです。不変の参照による書き込みは許可されていません。バイトコード検証は、リソースタイプの制限とともにこれらの規則を実施する参照安全性チェックを実行します（セクション5.2を参照）

![](./move/move008.png)


構造体とプリミティブ値に加えて、Moveは参照値もサポートします。参照は一時的なものであるため、他のMove値とは異なります。バイトコード検証では、参照型のフィールドは許可されません。つまり、トランザクションスクリプトの実行中に参照を作成し、そのトランザクションスクリプトの終了前に参照を解放する必要があります。

構造体値の形状の制限により、グローバル状態が常に任意のグラフではなくツリーになることが保証されます。状態ツリーの各ストレージの場所は、そのアクセスパス[24] —ストレージツリーのルート（ローカル変数𝑥またはグローバルリソースキーeither）からフィールドのシーケンスでマークされた子孫ノードまでのパスを使用して標準的に表すことができます。識別子𝑓。

この言語は、プリミティブ値と構造体への参照を許可しますが、他の参照への参照は許可しません。 
Moveプログラマーは、BorrowLoc命令を使用してローカル変数への参照を、BorrowField命令を使用して構造体のフィールドを、BorrowGlobal命令を使用してアカウントで公開されたリソースへの参照を取得できます。後者の2つの構造は、現在のモジュール内で宣言された構造型でのみ使用できます。

![](./move/move009.png)

プロシージャシグネチャは、可視性、型付きの仮パラメータ、および戻り値の型で構成されます。プロシージャ宣言には、署名、型付きローカル変数、およびバイトコード命令の配列が含まれます。手順の可視性は、パブリックまたは内部のいずれかです。

内部プロシージャは、同じモジュール内の他のプロシージャによってのみ呼び出すことができます。パブリックプロシージャは、任意のモジュールまたはトランザクションスクリプトによって呼び出すことができます。

ブロックチェーンの状態は、アカウントで現在公開されているモジュールのパブリックプロシージャを呼び出すことができるトランザクションスクリプトによって更新されます。トランザクションスクリプトは、関連するモジュールのない単なるプロシージャ宣言です。

プロシージャは、モジュール識別子と署名によって一意に識別できます。バイトコード呼び出し命令には、入力として一意のプロシージャIDが必要です。これにより、Moveのすべてのプロシージャコールが静的に決定されます。

関数ポインタや仮想コールはありません。さらに、モジュール間の依存関係は、構成上非周期的です。モジュールは、線形トランザクション履歴で以前に公開されたモジュールにのみ依存できます。非循環モジュール依存関係グラフと動的ディスパッチの欠如の組み合わせにより、強力な実行不変条件が強制されます。

モジュール内のプロシージャに属するすべてのスタックフレームは連続している必要があります。したがって、Moveモジュールにはイーサリアムスマートコントラクトの再入可能性[16]に相当する問題はありません。

このセクションの残りの部分では、バイトコード操作とそのセマンティクス（セクション5.1）を紹介し、モジュールコードの実行または保存（セクション5.2）を許可する前にバイトコード検証が実行する静的分析について説明します。




### Bytecode Interpreter

![](./move/move010.png)


Move bytecode命令は、Common Language Runtime [22]およびJava Virtual Machine [21]と同様のスタックベースのインタープリターによって実行されます。命令は、スタックからオペランドを消費し、結果をスタックにプッシュします。命令は、現在のプロシージャのローカル変数（仮パラメータを含む）との間で値を移動およびコピーすることもできます。

バイトコードインタープリターは、プロシージャコールをサポートしています。
呼び出し先に渡される入力値と呼び出し元に返される出力値も、スタックを介して通信されます。
最初に、呼び出し側はプロシージャの引数をスタックにプッシュします。次に、呼び出し元はCall命令を呼び出します。

これにより、呼び出し先の新しい呼び出しスタックフレームが作成され、プッシュされた値が呼び出し先のローカル変数にロードされます。
最後に、バイトコードインタープリターは、呼び出し先プロシージャのバイトコード命令の実行を開始します。

バイトコードの実行は、現在の手順で静的に決定されたオフセットへのジャンプを引き起こす分岐操作がない限り、操作を順番に実行することにより進行します。呼び出し先が戻りたい場合、戻り値をスタックにプッシュし、Return命令を呼び出します。次に、制御が呼び出し側に返され、呼び出し側がスタック上の出力値を見つけます。

Moveプログラムの実行は、EVMと同様の方法で測定されます[9]。
各バイトコード命令にはガス単位のコストが関連付けられており、実行するトランザクションにはガス単位の予算が含まれている必要があります。インタプリタは、実行中に残っているガスユニットを追跡し、残量がゼロに達するとエラーで停止します。

レジスタベースとスタックベースの両方のバイトコードインタープリターを検討し、型付きローカルを持つスタックマシンがMoveのリソースセマンティクスに非常に自然に適合することを発見しました。

ローカル変数、スタック、および呼び出し元/呼び出し先のペア間で値を移動する低レベルのメカニズムは、Moveプログラムの高レベルの意図を密接に反映しています。ローカルのないスタックマシンはより冗長であり、レジスタマシンはプロシージャの境界を越えてリソースを移動することをより複雑にします。


#### Instructions.

Moveは、バイトコード命令の6つの広範なカテゴリをサポートしています。

* •ローカル変数からスタックにデータをコピー/移動するためのCopyLoc / MoveLocなどの操作、
スタックからローカル変数にデータを移動するためのStoreLoc。
* •定数をスタックにプッシュするなどの型付きスタック値の操作、および算術
スタックオペランドのmetic / logical操作。
* •モジュールの宣言されたタイプを作成/破棄する Pack および Unpack 、アカウントの下でモジュールのタイプを公開/非公開する MoveToSender / MoveFrom、モジュールのいずれかのタイプのフィールドへの参照を取得するBorrowFieldなどのモジュール組み込み関数。
* •参照を読み取るためのReadRef、参照を書き込むためのWriteRef、参照を破棄するためのReleaseRef、可変参照を不変参照に変換するためのFreezeRefなどの参照関連の命令。
* •条件分岐やプロシージャからの呼び出し/戻りなどの制御フロー操作

* トランザクションスクリプトの送信者のアドレスの取得や新しいアカウントの作成など、ブロックチェーン固有の組み込み操作。


付録Aに、Moveバイトコード命令の完全なリストを示します。 Moveはsha3などの暗号化プリミティブも提供しますが、これらはバイトコード命令としてではなく、標準ライブラリのモジュールとして実装されます。

これらの標準ライブラリモジュールでは、プロシージャはネイティブとして宣言され、プロシージャ本体はMove VMによって提供されます。 VMのみが新しいネイティブプロシージャを定義できます。

つまり、これらの暗号化プリミティブは通常のバイトコード命令として実装できます。ただし、VMは各暗号プリミティブの呼び出し規約を再実装する代わりに、プロシージャを呼び出すための既存のメカニズムに依存できるため、ネイティブプロシージャが便利です。



### BytecodeVerifier

![](./move/move011.png)


バイトコード検証の目的は、公開用に送信されたモジュールおよび実行用に送信されたトランザクションスクリプトの安全プロパティを静的に適用することです。バイトコード検証を通過せずに、Moveプログラムを公開または実行することはできません。

バイトコード検証は、適切な形式のMoveプログラムを保持する必要がある一般的な安全プロパティを適用します。私たちは、将来の作業でプログラム固有のプロパティ用に別のオフライン検証ツールを開発することを目指しています
（セクション7を参照）。

Moveモジュールまたはトランザクションスクリプトのバイナリ形式は、定数、型シグネチャ、構造体定義、プロシージャ定義などのエンティティのテーブルのコレクションをエンコードします。検証者によって実行されるチェックは、3つのカテゴリに分類されます。

* •バイトコードテーブルが整形式であることを確認するための構造チェック。これらのチェックは、不正なテーブルインデックス、重複したテーブルエントリ、参照への参照などの不正なタイプシグネチャなどのエラーを検出します。
* •プロシージャボディのセマンティックチェック。これらのチェックは、不正なプロシージャ引数、参照のダングリング、リソースの複製などのエラーを検出します。
* •宣言型モジュールに対する構造体型とプロシージャシグネチャの使用のリンク。これらのチェックは、内部プロシージャの不正な呼び出しや、宣言と一致しないプロシージャ識別子の使用などのエラーを検出します。

このセクションの残りの部分では、セマンティック検証とリンクのフェーズについて説明します。


#### Control-flow graph construction. 

ベリファイアは、命令シーケンスを基本ブロックのコレクションに分解することにより、制御フローグラフを構築します（これらはブロックチェーン内のトランザクションの「ブロック」とは無関係です）。

各基本ブロックには、連続した一連の命令が含まれています。すべての命令のセットはブロック間で分割されます。各基本ブロックは、分岐命令またはリターン命令で終了します。分解は、ブランチがいくつかの基本ブロックの開始時にのみ土地をターゲットにすることを保証します。

分解はまた、生成されたブロックが最大であることを保証しようとします。ただし、バイトコード検証の健全性は最大に依存しません。

#### Stack balance checking.


スタックバランスチェックにより、呼び出し先が呼び出し元に属するスタックの場所にアクセスできないことが保証されます。基本ブロックの実行は、ローカル変数の配列とスタックのコンテキストで発生します。

プロシージャのパラメータは、ローカル変数の配列のプレフィックスです。プロシージャコール間で引数と戻り値を渡すことは、スタックを介して行われます。プロシージャの実行が開始されると、その引数はすでにパラメータにロードされています。プロシージャの実行開始時のスタックの高さがnであるとします。

有効なバイトコードは、実行が基本ブロックの終わりに達したとき、スタックの高さがnであるという不変式を満たす必要があります。

ベリファイアは、各基本ブロックを個別に分析し、スタックの高さに対する各命令の効果を計算することにより、これを保証します。高さがnを下回らないこと、および基本ブロック出口でnであることを確認します。 1つの例外は、Return命令で終わるブロックです。ここで、高さはn + m（mはプロシージャによって返される値の数）でなければなりません。


#### Type checking. 

ベリファイアの第2フェーズでは、各命令とプロシージャ（組み込みプロシージャとユーザー定義プロシージャの両方を含む）が適切な型の引数で呼び出されることを確認します。

命令のオペランドは、ローカル変数またはスタック上にある値です。

プロシージャのローカル変数のタイプは、すでにバイトコードで提供されています。
ただし、スタック値のタイプは推測されます。
この操作と各操作の型チェックは、基本ブロックごとに個別に実行されます。各基本ブロックの先頭のスタックの高さはnであり、ブロックの実行中にnを下回らないため、ブロック命令の型チェックのためにnで始まるスタックのサフィックスをモデル化するだけです。

基本ブロックの命令シーケンスが処理されるときに型がプッシュおよびポップされる型のスタックを使用して、この接尾辞をモデル化します。型スタックと静的に既知のローカル変数の型は、各バイトコード命令の型チェックに十分です。

#### Kind checking.


検証者は、型チェックフェーズ中に次の追加チェックを介してリソースの安全性を強化します。

* リソースは複製できません。CopyLocはkindリソースのローカル変数では使用されず、ReadRefはkindリソースの値への参照であるタイプのスタック値では使用されません。
* リソースを破棄することはできません：PopUnrestrictedは種類のリソースのスタックの場所では使用されません。StoreLocは既にリソースを保持しているローカル変数では使用されず、WriteRefは種類のリソースの値への参照では実行されません。
* リソースを使用する必要があります：プロシージャが戻るとき、ローカル変数はリソース値を保持できません。また、評価スタックの呼び出し先のセグメントはプロシージャの戻り値のみを保持する必要があります。


非リソース構造体タイプには種類リソースのフィールドを含めることはできないため、これらのチェックは（たとえば）リソースフィールドを持つ非リソース構造体をコピーすることによって覆すことはできません。

エラーで停止するプログラム実行によってリソースを破壊することはできません。
セクション4.2で説明したように、トランザクションスクリプトの部分的な実行によって生成される状態の変更は、グローバル状態にコミットされません。これは、実行時障害時にスタック上またはローカル変数内にあるリソースが、トランザクションの実行が開始される前の場所に（効果的に）戻ることを意味します。

原則として、リソースは、終了しないプログラムの実行によって到達不能になる可能性があります。
ただし、セクション5.1で説明したガスメータリングスキームにより、Moveプログラムの実行は常に終了します。
ガスを使い果たした実行はエラーで停止しますが、リソースの損失は発生しません（上で説明したように）。


#### Reference checking. 

参照の安全性は、静的分析と動的分析の組み合わせを使用して確認されます。静的分析では、Rust型システムと同様の方法で借用チェックを使用しますが、ソースコードレベルではなくバイトコードレベルで実行されます。これらの参照チェックにより、2つの強力なプロパティが確保されます。

* すべての参照は、割り当てられたストレージを指します（つまり、ダングリングポインタは存在しません）。

* すべての参照には、安全な読み取りおよび書き込みアクセスがあります。参照は、共有（書き込みアクセスおよび自由な読み取りアクセスなし）または排他的（読み取りおよび書き込みアクセスが制限された）のいずれかです。


これらのプロパティがBorrowGlobalを介して作成されたグローバルストレージへの参照を保持するために、バイトコードインタープリターは軽量の動的参照カウントを実行します。インタープリターは、公開された各リソースへの未解決の参照の数を追跡します。そのリソースへの参照がまだ存在している間にグローバルリソースが借用または移動された場合、この情報を使用してエラーで停止します。

この参照チェック方式には多くの新しい機能があり、別の論文のトピックになります。


![](./move/move0111.png)


バイトコードの検証中、ベリファイアは、現在のコードユニットで使用されている外部構造体タイプとプロシージャIDが存在し、忠実に表現されていると想定します。リンク手順では、グローバル状態Σから構造体とプロシージャの宣言を読み取り、宣言がその使用法と一致することを確認することにより、この仮定をチェックします。具体的には、リンカは、グローバル状態の次の宣言が現在のコードユニットでの使用法と一致することを確認します。

* •構造体宣言（名前と種類）。
* •プロシージャシグネチャ（名前、可視性、仮パラメータタイプ、および戻り値タイプ）]



## 6. Move Virtual Machine: Putting It All Together

![](./move/move112.png)

Move仮想マシンの役割は、グローバル状態ΣからトランザクションのブロックBを実行し、グローバル状態への変更を表すトランザクション効果Eを生成することです。

次に、効果effectをΣに適用して、𝐵の実行から生じる状態Σ 'を生成できます。

実際の状態の更新から効果を分離することにより、VMは実行エラーの場合にトランザクションのセマンティクスを実装できます。
直感的に、トランザクション効果は、アカウントのサブセットでグローバル状態への更新を示します。

トランザクション効果は、グローバル状態と同じ構造を持ちます。
これは、アカウントアドレスからアカウントへの部分的なマップであり、Moveモジュールとリソース値の正規にシリアル化された表現が含まれます。

正規のシリアル化は、Moveモジュールまたはリソースからバイト配列への言語に依存しない1-1関数を実装します。

状態 $Σ_{𝑖-1} $ からブロック B をexecuteするために、VMはtransactionからトランザクション$𝑇_𝑖$ をフェッチし、それを処理した結果 $𝐸_𝑖$ を生成し、次に$𝐸_𝑖$ を $Σ_{𝑖-1} $ に適用して状態 $Σ_𝑖$ を生成し、それをそのブロック内の次のトランザクションの初期状態として使用します。
そのブロック全体への効果は、ブロック内の各トランザクションの効果の順序付けられた構成となることです。

各トランザクションは、トランザクション内のバイトコードの検証やトランザクション送信者の署名の確認などの手順を含むワークフローに従って処理されます。単一のトランザクションを実行するためのワークフロー全体については、[2]で詳細に説明しています。

現在、ブロック内のトランザクションはVMによって順次実行されますが、Move言語は並列実行をサポートするように設計されています。

原則として、トランザクションを実行すると、一連の読み取りと一連の書き込み効果が生成されますcould。ブロック内の各トランザクションは、その読み取り/書き込みセットがブロック内の別のトランザクションと競合する場合にのみ、投機的に並列実行され、再実行されます。

 Moveのツリーメモリモデルにより、アクセスパスを使用してグローバルメモリセルを一意に識別できるため、競合のチェックは簡単です。仮想マシンのパフォーマンスがLibra Blockchainのボトルネックになる場合、将来投機的な実行スキームを検討します。

## 7. What'sNextforMove

これまでのところ、Moveの次のコンポーネントを設計および実装しています。

* ブロックチェーンの実行に適したプログラミングモデル。
* このプログラム可能なモデルに適合するバイトコード言語。
* 強力なデータ抽象化とアクセス制御の両方を備えたライブラリを実装するためのモジュールシステム。
* シリアライザー/デシリアライザー、バイトコード検証、およびバイトコードインタープリターで構成される仮想マシン。


こういった進展にもかかわらずまだ長い道のりがあります。

最後に、Moveのいくつかの即時の次のステップと長期計画について説明します。

### Libra Blockchainのコア機能の実装。 

Moveを使用して、Libra Blockchainのコア機能を実装します：アカウント、Libraコイン、Libraリザーブ管理、検証ノードの追加と削除、トランザクション料金の収集と配布、コールドウォレットなど。この作業はすでに進行中です。

### 言語の新機能。

パラメトリックポリモーフィズム（ジェネリック）、コレクション、およびイベントをMove言語に追加します。パラメトリック多型は、Moveの既存の安全性と検証可能性の保証を損なうものではありません。私たちの設計では、種類（つまり、リソースまたは無制限）の制約を持つ型パラメーターを[25]と同様の方法でプロシージャと構造体に追加します。

さらに、Moveモジュール、トランザクションスクリプト、および公開されたリソースをバージョン管理および更新するための信頼できるメカニズムを開発します。


### 開発者エクスペリエンスの向上。 

Move IRは、Moveバイトコード検証ツールと仮想マシンのテストツールとして開発されました。これらのコンポーネントを実行するには、
IRコンパイラーは、バイトコード検証によって拒否される（たとえば）不良バイトコードを意図的に生成する必要があります。
つまり、IRはMoveプログラムのプロトタイピングには適していますが、特にユーザーフレンドリーではありません。 

Moveをサードパーティ開発にとってより魅力的なものにするために、IRを改善し、人間工学に基づいたMoveソース言語の開発に向けて取り組みます。


### 形式的な仕様記述と検証。 

Moveの検証に適した設計を活用する論理仕様言語と自動化された正式な検証ツールを作成します（セクション3.4を参照）。
検証ツールチェーンは、Moveバイトコード検証（セクション5.2）によって実施される安全性の保証を超える、プログラム固有の機能的正確性プロパティをチェックします。

最初の焦点は、Libra Blockchainのコア機能を実装するモジュールを指定および検証することです。

長期的な目標は、ユーザーがモジュールの機能を理解するためにモジュールの正式な仕様に目を向ける、正しい文化を促進することです。
理想的には、包括的な正式な仕様があり、その仕様を満たしていることが確認されていない限り、Moveプログラマはモジュールとやり取りすることはありません。
ただし、この目標を達成するには、いくつかの技術的および社会的課題があります。

検証ツールは、正確で直感的でなければなりません。
仕様はモジュール式で再利用可能である必要がありますが、モジュールの動作の有用なドキュメントとして役立つほど十分に読みやすいものでなければなりません。

サードパーティのMoveモジュールをサポートします。
サードパーティのモジュール公開へのパスを開発します。 
Libraユーザーとサードパーティの開発者の両方に優れたエクスペリエンスを提供することは、大きな課題です。

まず、一般的なアプリケーションへの扉を開いても、中核となる支払いシナリオおよび関連する金融アプリケーションに対するシステムの使いやすさに影響を与えてはなりません。
第二に、詐欺、憶測、バグのあるソフトウェアが存在するという評判のリスクを回避したいと考えています。
高いソフトウェア品質を促進しながらオープンシステムを構築することは難しい問題です。
高保証モジュールのマーケットプレイスを作成したり、Moveコードを検証するための効果的なツールを提供するなどの手順が役立ちます。



## A. Move Language Reference

![](./move/move0a01.png)

![](./move/move0a02.png)

![](./move/move0a03.png)

![](./move/move0a04.png)

![](./move/move0a05.png)

![](./move/move0a06.png)

![](./move/move0a07.png)


##References

[1] The Libra Association, “An Introduction to Libra.” https://libra.org/en-us/whitepaper.

[2] Z. Amsden et al., “The Libra Blockchain.” https://developers.libra.org/docs/the-libra-blockchain-
paper.

[3] J. Girard, “Linear logic,” Theor. Comput. Sci., 1987.

[4] L. Lamport, “Using time instead of timeout for fault-tolerant distributed systems,” ACM Trans. Program. Lang. Syst., 1984.

[5] S. Bano et al., “State machine replication in the Libra Blockchain.” https://developers.libra.org /docs/state-machine-replication-paper.

[6] M. Saad et al., “Exploring the attack surface of blockchain: A systematic overview,” CoRR, 2019.

[7] S. Nakamoto, “Bitcoin: A peer-to-peer electronic cash system,” 2008. http://bitcoin.org/bitcoin. pdf

[8] bitcoin.org, “Bitcoin script.”. https://en.bitcoin.it/wiki/Script

[9] G. Wood, “Ethereum: A secure decentralised generalised transaction ledger,” 2014. https://ethe
reum.github.io/yellowpaper/paper.pdf

[10] bitcoin.org, “Multisignature.”. https://en.bitcoin.it/wiki/Multisignature

[11] M. Bartoletti and R. Zunino, “BitML: A calculus for Bitcoin smart contracts,” in Proceedings of the ACM SIGSAC conference on computer and communications security, 2018.

[12] bitcoin.org, “Colored coin.”. https://en.bitcoin.it/wiki/Colored_Coin

[13] K. Crary and M. J. Sullivan, “Peer-to-peer affine commitment using bitcoin,” in Proceedings of
the ACM SIGPLAN conference on programming language design and implementation, 2015.

[14] N. Szabo, “Formalizing and securing relationships on public networks,” First Monday, vol. 2, no.
9, 1997. https://ojphi.org/ojs/index.php/fm/article/view/548

[15] V. Buterin and F. Vogelsteller, “ERC20 token standard.” 2015. https://theethereum.wiki/w/i
ndex.php/ERC20_Token_Standard

[16] I. Sergey and A. Hobor, “A concurrent perspective on smart contracts,” in Financial cryptography and data security, 2017.

[17] V. Buterin, “Critical update re DAO.” 2016. https://ethereum.github.io/blog/2016/06/17/criti cal-update-re-dao-vulnerability

[18] “The Parity wallet hack explained.” 2017. https://blog.zeppelin.solutions/on-the-parity-wallet- multisig-hack-405a8c12e8f7

[19] C. Catalini, O. Gratry, J. M. Hou, S. Parasuraman, and N. Wernerfelt, “The Libra reserve.” https://libra.org/about-currency-reserve.

[20] R. Milner, M. Tofte, and R. Harper, “Definition of standard ML,” 1990.

[21] T. Lindholm and F. Yellin, The Java virtual machine specification. Addison-Wesley, 1997. 22] E. Meijer, R. Wa, and J. Gough, “Technical overview of the common language runtime.” 2000.
25

[23] D. Walker, “Substructural type systems,” in Advanced topics in types and programming languages, The MIT Press, 2004.

[24] N. D. Jones and S. S. Muchnick, “Flow analysis and optimization of LISP-like structures,” in POPL, 1979.

[25] K. Mazurak, J. Zhao, and S. Zdancewic, “Lightweight linear types in System F,” in Proceedings of the ACM SIGPLAN international workshop on types in languages design and implementation, 2010.
